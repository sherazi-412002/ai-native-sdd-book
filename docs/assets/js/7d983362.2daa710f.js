"use strict";(globalThis.webpackChunkclassic=globalThis.webpackChunkclassic||[]).push([[2003],{7399(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>_,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-1/rclpy-bridging","title":"rclpy Bridging: Python Integration for Autonomous Humanoid Robotics","description":"Introduction to rclpy","source":"@site/docs/module-1/rclpy-bridging.md","sourceDirName":"module-1","slug":"/module-1/rclpy-bridging","permalink":"/ai-native-sdd-books/docs/module-1/rclpy-bridging","draft":false,"unlisted":false,"editUrl":"https://github.com/sherazi-412002/ai-native-sdd-books/tree/main/docs/module-1/rclpy-bridging.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"curriculumSidebar","previous":{"title":"Nodes, Topics, and Services: The Nervous System of Autonomous Humanoid Robots","permalink":"/ai-native-sdd-books/docs/module-1/nodes-topics-services"},"next":{"title":"URDF Humanoids: Advanced Robot Modeling for Autonomous Humanoid Systems","permalink":"/ai-native-sdd-books/docs/module-1/urdf-humanoids"}}');var i=t(4848),s=t(8453);const r={sidebar_position:2},o="rclpy Bridging: Python Integration for Autonomous Humanoid Robotics",l={},c=[{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Theoretical Foundation of Python Integration",id:"theoretical-foundation-of-python-integration",level:2},{value:"Language Bridge Architecture",id:"language-bridge-architecture",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Advanced Publisher Implementation",id:"advanced-publisher-implementation",level:2},{value:"Advanced Subscriber Implementation",id:"advanced-subscriber-implementation",level:2},{value:"Advanced Service and Client Implementation for Humanoid Robotics",id:"advanced-service-and-client-implementation-for-humanoid-robotics",level:2},{value:"Advanced Parameter Management with Dynamic Reconfiguration",id:"advanced-parameter-management-with-dynamic-reconfiguration",level:2},{value:"Integration with NVIDIA Isaac Sim for Humanoid Robotics",id:"integration-with-nvidia-isaac-sim-for-humanoid-robotics",level:2},{value:"Best Practices for rclpy in Humanoid Robotics",id:"best-practices-for-rclpy-in-humanoid-robotics",level:2},{value:"1. Performance Optimization",id:"1-performance-optimization",level:3},{value:"2. Error Handling and Safety",id:"2-error-handling-and-safety",level:3},{value:"3. Memory Management",id:"3-memory-management",level:3},{value:"4. Parameter Management",id:"4-parameter-management",level:3},{value:"5. Testing and Debugging",id:"5-testing-and-debugging",level:3},{value:"Summary",id:"summary",level:2},{value:"Integration with NVIDIA Isaac Sim",id:"integration-with-nvidia-isaac-sim",level:2},{value:"Best Practices for rclpy in Humanoid Robotics",id:"best-practices-for-rclpy-in-humanoid-robotics-1",level:2},{value:"1. Performance Optimization",id:"1-performance-optimization-1",level:3},{value:"2. Error Handling and Safety",id:"2-error-handling-and-safety-1",level:3},{value:"3. Memory Management",id:"3-memory-management-1",level:3},{value:"4. Parameter Management",id:"4-parameter-management-1",level:3},{value:"5. Testing and Debugging",id:"5-testing-and-debugging-1",level:3},{value:"Summary",id:"summary-1",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rclpy-bridging-python-integration-for-autonomous-humanoid-robotics",children:"rclpy Bridging: Python Integration for Autonomous Humanoid Robotics"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,i.jsx)(n.p,{children:"rclpy is the Python client library for ROS 2, providing access to ROS 2 capabilities from Python. This library serves as a critical bridge between the Python-based ecosystem of scientific computing, machine learning, and AI tools and the ROS 2 framework. For humanoid robotics applications, rclpy enables the integration of sophisticated Python-based algorithms such as computer vision, machine learning models, and high-level planning systems into the real-time control framework of ROS 2."}),"\n",(0,i.jsx)(n.p,{children:"Python's rich ecosystem of libraries for robotics and AI makes rclpy an invaluable tool for humanoid robot development. Libraries such as NumPy, SciPy, OpenCV, TensorFlow, PyTorch, and scikit-learn can be seamlessly integrated with ROS 2 through rclpy, enabling the development of intelligent humanoid behaviors that leverage state-of-the-art AI and machine learning techniques."}),"\n",(0,i.jsx)(n.h2,{id:"theoretical-foundation-of-python-integration",children:"Theoretical Foundation of Python Integration"}),"\n",(0,i.jsx)(n.p,{children:"The integration of Python with ROS 2 through rclpy is built on several key theoretical concepts:"}),"\n",(0,i.jsx)(n.h3,{id:"language-bridge-architecture",children:"Language Bridge Architecture"}),"\n",(0,i.jsx)(n.p,{children:"rclpy implements a Python wrapper around the underlying ROS 2 C++ client library (rcl). This architecture provides:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Management"}),": Automatic garbage collection and memory management through Python's reference counting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Conversion"}),": Automatic conversion between Python and ROS 2 message types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exception Handling"}),": Python exception handling integrated with ROS 2 error reporting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading Model"}),": Integration with Python's Global Interpreter Lock (GIL) and ROS 2's threading model"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:"While Python provides ease of development and access to rich libraries, performance considerations are important for real-time robotics applications:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Computationally Intensive Tasks"}),": Should be offloaded to C++ nodes when real-time performance is critical"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Processing"}),": Python is suitable for message processing that doesn't require hard real-time guarantees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Algorithm Development"}),": Python excels in prototyping and development of complex algorithms that can later be optimized"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-publisher-implementation",children:"Advanced Publisher Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\nfrom std_msgs.msg import String, Header\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist, Vector3\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport threading\nimport time\nfrom collections import deque\nimport json\n\nclass AdvancedHumanoidPublisherNode(Node):\n    \"\"\"\n    Advanced publisher node demonstrating complex rclpy usage patterns for humanoid robotics.\n    This implementation includes multiple publishers with different QoS profiles,\n    message buffering, and real-time performance considerations.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_humanoid_publisher_node')\n\n        # Declare parameters\n        self.declare_parameter('publish_frequency', 100)  # Hz\n        self.declare_parameter('robot_name', 'autonomous_humanoid')\n        self.declare_parameter('max_buffer_size', 100)\n        self.declare_parameter('enable_diagnostics', True)\n\n        # Get parameter values\n        self.publish_frequency = self.get_parameter('publish_frequency').value\n        self.robot_name = self.get_parameter('robot_name').value\n        self.max_buffer_size = self.get_parameter('max_buffer_size').value\n        self.enable_diagnostics = self.get_parameter('enable_diagnostics').value\n\n        # Create QoS profiles for different types of data\n        # High-frequency sensor data with reliable delivery\n        self.qos_sensor = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Control commands requiring best-effort delivery but with low latency\n        self.qos_control = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Diagnostics data that should be kept for late-joining subscribers\n        self.qos_diagnostics = QoSProfile(\n            depth=5,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.TRANSIENT_LOCAL,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Publishers for different types of data\n        self.joint_state_publisher = self.create_publisher(\n            JointState,\n            f'/{self.robot_name}/joint_states',\n            self.qos_sensor\n        )\n\n        self.imu_publisher = self.create_publisher(\n            Imu,\n            f'/{self.robot_name}/imu/data',\n            self.qos_sensor\n        )\n\n        self.diagnostic_publisher = self.create_publisher(\n            String,\n            f'/{self.robot_name}/diagnostics',\n            self.qos_diagnostics\n        )\n\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            f'/{self.robot_name}/cmd_vel',\n            self.qos_control\n        )\n\n        # Initialize message buffers for performance optimization\n        self.joint_state_buffer = deque(maxlen=self.max_buffer_size)\n        self.imu_buffer = deque(maxlen=self.max_buffer_size)\n        self.diagnostic_buffer = deque(maxlen=self.max_buffer_size)\n\n        # Initialize joint names for humanoid robot\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\n            'head_yaw_joint', 'head_pitch_joint'\n        ]\n\n        # Initialize joint state data\n        self.initialize_joint_state()\n\n        # Create timer for publishing loop\n        self.publish_timer = self.create_timer(\n            1.0 / self.publish_frequency,\n            self.publish_loop\n        )\n\n        # Performance tracking\n        self.publish_times = deque(maxlen=100)\n        self.message_counts = {\n            'joint_states': 0,\n            'imu_data': 0,\n            'diagnostics': 0,\n            'cmd_vel': 0\n        }\n\n        self.get_logger().info(\n            f'Advanced Humanoid Publisher Node initialized for {self.robot_name} '\n            f'with publish frequency {self.publish_frequency}Hz'\n        )\n\n    def initialize_joint_state(self):\n        \"\"\"Initialize joint state with default values.\"\"\"\n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_efforts = [0.0] * len(self.joint_names)\n\n    def generate_joint_state_data(self):\n        \"\"\"Generate realistic joint state data for humanoid robot.\"\"\"\n        # Simulate joint positions with some realistic movement patterns\n        current_time = self.get_clock().now()\n        time_sec = current_time.nanoseconds / 1e9\n\n        # Create oscillating patterns for different joint groups\n        for i, joint_name in enumerate(self.joint_names):\n            # Different oscillation patterns for different joint types\n            if 'hip' in joint_name:\n                # Hip joints with slower oscillation\n                self.joint_positions[i] = 0.1 * np.sin(0.5 * time_sec + i)\n                self.joint_velocities[i] = 0.1 * 0.5 * np.cos(0.5 * time_sec + i)\n            elif 'knee' in joint_name:\n                # Knee joints with medium oscillation\n                self.joint_positions[i] = 0.05 * np.sin(1.0 * time_sec + i)\n                self.joint_velocities[i] = 0.05 * 1.0 * np.cos(1.0 * time_sec + i)\n            elif 'shoulder' in joint_name:\n                # Shoulder joints with faster oscillation\n                self.joint_positions[i] = 0.2 * np.sin(2.0 * time_sec + i)\n                self.joint_velocities[i] = 0.2 * 2.0 * np.cos(2.0 * time_sec + i)\n            else:\n                # Other joints with random small movements\n                self.joint_positions[i] = 0.01 * np.sin(3.0 * time_sec + i)\n                self.joint_velocities[i] = 0.01 * 3.0 * np.cos(3.0 * time_sec + i)\n\n            # Effort is proportional to velocity (simplified model)\n            self.joint_efforts[i] = 0.1 * self.joint_velocities[i]\n\n    def generate_imu_data(self):\n        \"\"\"Generate realistic IMU data for humanoid robot.\"\"\"\n        current_time = self.get_clock().now()\n        time_sec = current_time.nanoseconds / 1e9\n\n        # Simulate IMU data with realistic noise and movement\n        imu_msg = Imu()\n\n        # Timestamp\n        imu_msg.header.stamp = current_time.to_msg()\n        imu_msg.header.frame_id = f'{self.robot_name}_imu_link'\n\n        # Orientation (simplified - just small oscillations around upright)\n        imu_msg.orientation.x = 0.01 * np.sin(0.1 * time_sec)\n        imu_msg.orientation.y = 0.01 * np.cos(0.1 * time_sec)\n        imu_msg.orientation.z = 0.0\n        imu_msg.orientation.w = np.sqrt(1 - (\n            imu_msg.orientation.x**2 +\n            imu_msg.orientation.y**2 +\n            imu_msg.orientation.z**2\n        ))\n\n        # Angular velocity (body rotation)\n        imu_msg.angular_velocity.x = 0.05 * np.cos(0.2 * time_sec)\n        imu_msg.angular_velocity.y = 0.05 * np.sin(0.2 * time_sec)\n        imu_msg.angular_velocity.z = 0.01 * np.sin(0.5 * time_sec)\n\n        # Linear acceleration (with gravity component)\n        imu_msg.linear_acceleration.x = 0.5 * np.sin(0.3 * time_sec)\n        imu_msg.linear_acceleration.y = 0.5 * np.cos(0.3 * time_sec)\n        imu_msg.linear_acceleration.z = -9.81 + 0.2 * np.sin(0.4 * time_sec)\n\n        return imu_msg\n\n    def generate_diagnostics(self):\n        \"\"\"Generate diagnostic information for the humanoid robot.\"\"\"\n        diag_data = {\n            'timestamp': self.get_clock().now().nanoseconds / 1e9,\n            'robot_name': self.robot_name,\n            'publish_frequency': self.publish_frequency,\n            'joint_count': len(self.joint_names),\n            'message_counts': dict(self.message_counts),\n            'average_publish_time_ms': np.mean(self.publish_times) if self.publish_times else 0.0,\n            'buffer_sizes': {\n                'joint_state_buffer': len(self.joint_state_buffer),\n                'imu_buffer': len(self.imu_buffer),\n                'diagnostic_buffer': len(self.diagnostic_buffer)\n            }\n        }\n\n        diag_msg = String()\n        diag_msg.data = json.dumps(diag_data, indent=2)\n        return diag_msg\n\n    def publish_loop(self):\n        \"\"\"Main publishing loop executing at specified frequency.\"\"\"\n        start_time = time.time()\n\n        # Generate and publish joint states\n        self.generate_joint_state_data()\n        joint_msg = self.create_joint_state_message()\n        self.joint_state_publisher.publish(joint_msg)\n        self.message_counts['joint_states'] += 1\n\n        # Generate and publish IMU data\n        imu_msg = self.generate_imu_data()\n        self.imu_publisher.publish(imu_msg)\n        self.message_counts['imu_data'] += 1\n\n        # Publish diagnostics periodically (every 10th cycle if enabled)\n        if self.enable_diagnostics and self.message_counts['joint_states'] % 10 == 0:\n            diag_msg = self.generate_diagnostics()\n            self.diagnostic_publisher.publish(diag_msg)\n            self.message_counts['diagnostics'] += 1\n\n        # Publish command velocity (for demonstration)\n        cmd_vel_msg = Twist()\n        cmd_vel_msg.linear.x = 0.1  # Small forward velocity\n        cmd_vel_msg.angular.z = 0.01  # Small angular velocity\n        self.cmd_vel_publisher.publish(cmd_vel_msg)\n        self.message_counts['cmd_vel'] += 1\n\n        # Track performance\n        end_time = time.time()\n        publish_time_ms = (end_time - start_time) * 1000\n        self.publish_times.append(publish_time_ms)\n\n        # Log performance if it exceeds threshold\n        if publish_time_ms > 10.0:  # More than 10ms to publish\n            self.get_logger().warn(f'Publishing took {publish_time_ms:.2f}ms')\n\n    def create_joint_state_message(self):\n        \"\"\"Create a JointState message with current joint data.\"\"\"\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = f'{self.robot_name}_base_link'\n        msg.name = self.joint_names\n        msg.position = self.joint_positions\n        msg.velocity = self.joint_velocities\n        msg.effort = self.joint_efforts\n\n        return msg\n\n    def get_performance_metrics(self):\n        \"\"\"Get current performance metrics.\"\"\"\n        return {\n            'average_publish_time_ms': np.mean(self.publish_times) if self.publish_times else 0.0,\n            'publish_frequency_actual': self.publish_frequency,\n            'message_counts': dict(self.message_counts)\n        }\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = AdvancedHumanoidPublisherNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-subscriber-implementation",children:"Advanced Subscriber Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom builtin_interfaces.msg import Time\nimport numpy as np\nimport threading\nfrom collections import deque\nimport time\nfrom scipy import signal\nimport json\n\nclass AdvancedHumanoidSubscriberNode(Node):\n    \"\"\"\n    Advanced subscriber node demonstrating complex rclpy usage patterns for humanoid robotics.\n    This implementation includes message filtering, real-time processing, and data fusion.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_humanoid_subscriber_node')\n\n        # Declare parameters\n        self.declare_parameter('processing_frequency', 100)  # Hz\n        self.declare_parameter('robot_name', 'autonomous_humanoid')\n        self.declare_parameter('enable_filtering', True)\n        self.declare_parameter('filter_cutoff_freq', 10.0)  # Hz\n\n        # Get parameter values\n        self.processing_frequency = self.get_parameter('processing_frequency').value\n        self.robot_name = self.get_parameter('robot_name').value\n        self.enable_filtering = self.get_parameter('enable_filtering').value\n        self.filter_cutoff_freq = self.get_parameter('filter_cutoff_freq').value\n\n        # Create QoS profiles\n        self.qos_sensor = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        self.qos_control = QoSProfile(\n            depth=1,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # Subscribers for different types of data\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            f'/{self.robot_name}/joint_states',\n            self.joint_state_callback,\n            self.qos_sensor\n        )\n\n        self.imu_subscriber = self.create_subscription(\n            Imu,\n            f'/{self.robot_name}/imu/data',\n            self.imu_callback,\n            self.qos_sensor\n        )\n\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist,\n            f'/{self.robot_name}/cmd_vel',\n            self.cmd_vel_callback,\n            self.qos_control\n        )\n\n        self.diagnostic_subscriber = self.create_subscription(\n            String,\n            f'/{self.robot_name}/diagnostics',\n            self.diagnostic_callback,\n            self.qos_sensor\n        )\n\n        # Initialize data storage with buffers\n        self.joint_state_buffer = deque(maxlen=100)\n        self.imu_buffer = deque(maxlen=100)\n        self.cmd_vel_buffer = deque(maxlen=50)\n\n        # Initialize filtered data storage\n        self.filtered_joint_positions = {}\n        self.filtered_joint_velocities = {}\n        self.filtered_imu_data = {}\n\n        # Initialize joint names and create filters\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',\n            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint',\n            'head_yaw_joint', 'head_pitch_joint'\n        ]\n\n        # Create low-pass filters for each joint\n        self.joint_filters = {}\n        if self.enable_filtering:\n            for joint_name in self.joint_names:\n                self.joint_filters[joint_name] = self.create_low_pass_filter()\n\n        # Initialize state variables\n        self.current_joint_state = None\n        self.current_imu_data = None\n        self.current_cmd_vel = None\n\n        # Create timer for processing loop\n        self.processing_timer = self.create_timer(\n            1.0 / self.processing_frequency,\n            self.process_sensor_data\n        )\n\n        # Performance tracking\n        self.processing_times = deque(maxlen=100)\n        self.message_counts = {\n            'joint_states_received': 0,\n            'imu_received': 0,\n            'cmd_vel_received': 0,\n            'diagnostics_received': 0\n        }\n\n        self.get_logger().info(\n            f'Advanced Humanoid Subscriber Node initialized for {self.robot_name} '\n            f'with processing frequency {self.processing_frequency}Hz'\n        )\n\n    def create_low_pass_filter(self):\n        \"\"\"Create a low-pass filter for signal processing.\"\"\"\n        # Create a simple low-pass filter\n        # This is a simplified implementation - in practice, you might use more sophisticated filters\n        sos = signal.butter(4, self.filter_cutoff_freq, 'low', fs=self.processing_frequency, output='sos')\n        return sos\n\n    def joint_state_callback(self, msg):\n        \"\"\"Callback for joint state messages.\"\"\"\n        self.message_counts['joint_states_received'] += 1\n\n        # Store in buffer for real-time processing\n        self.joint_state_buffer.append({\n            'timestamp': msg.header.stamp,\n            'joint_names': msg.name,\n            'positions': list(msg.position),\n            'velocities': list(msg.velocity),\n            'efforts': list(msg.effort)\n        })\n\n        # Update current state\n        self.current_joint_state = msg\n\n        # Log if message rate is too high/low\n        if self.message_counts['joint_states_received'] % 1000 == 0:\n            self.get_logger().info(\n                f'Received {self.message_counts[\"joint_states_received\"]} joint state messages'\n            )\n\n    def imu_callback(self, msg):\n        \"\"\"Callback for IMU messages.\"\"\"\n        self.message_counts['imu_received'] += 1\n\n        # Store in buffer\n        self.imu_buffer.append({\n            'timestamp': msg.header.stamp,\n            'orientation': [msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w],\n            'angular_velocity': [msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z],\n            'linear_acceleration': [msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]\n        })\n\n        # Update current state\n        self.current_imu_data = msg\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Callback for velocity command messages.\"\"\"\n        self.message_counts['cmd_vel_received'] += 1\n\n        # Store in buffer\n        self.cmd_vel_buffer.append({\n            'timestamp': self.get_clock().now(),\n            'linear': [msg.linear.x, msg.linear.y, msg.linear.z],\n            'angular': [msg.angular.x, msg.angular.y, msg.angular.z]\n        })\n\n        # Update current command\n        self.current_cmd_vel = msg\n\n    def diagnostic_callback(self, msg):\n        \"\"\"Callback for diagnostic messages.\"\"\"\n        self.message_counts['diagnostics_received'] += 1\n\n        try:\n            # Parse diagnostic data\n            diag_data = json.loads(msg.data)\n            self.get_logger().debug(f'Diagnostic data: {diag_data}')\n        except json.JSONDecodeError:\n            self.get_logger().warn('Failed to parse diagnostic message')\n\n    def process_sensor_data(self):\n        \"\"\"Process sensor data in real-time.\"\"\"\n        start_time = time.time()\n\n        # Process joint state data\n        if self.current_joint_state:\n            self.process_joint_data()\n\n        # Process IMU data\n        if self.current_imu_data:\n            self.process_imu_data()\n\n        # Process command velocity\n        if self.current_cmd_vel:\n            self.process_cmd_vel_data()\n\n        # Calculate processing time\n        end_time = time.time()\n        processing_time_ms = (end_time - start_time) * 1000\n        self.processing_times.append(processing_time_ms)\n\n        # Log warning if processing takes too long\n        if processing_time_ms > 10.0:  # More than 10ms\n            self.get_logger().warn(f'Processing took {processing_time_ms:.2f}ms')\n\n    def process_joint_data(self):\n        \"\"\"Process joint state data with filtering and analysis.\"\"\"\n        if not self.current_joint_state:\n            return\n\n        # Apply filtering if enabled\n        if self.enable_filtering:\n            filtered_positions = []\n            for i, joint_name in enumerate(self.current_joint_state.name):\n                if joint_name in self.joint_filters and i < len(self.current_joint_state.position):\n                    # Apply filter (simplified - in practice, maintain filter state)\n                    pos = self.current_joint_state.position[i]\n                    filtered_pos = self.apply_filter(self.joint_filters[joint_name], pos)\n                    filtered_positions.append(filtered_pos)\n                else:\n                    filtered_positions.append(self.current_joint_state.position[i])\n\n            # Store filtered data\n            for i, joint_name in enumerate(self.current_joint_state.name):\n                if i < len(filtered_positions):\n                    self.filtered_joint_positions[joint_name] = filtered_positions[i]\n\n        # Perform joint analysis\n        self.analyze_joint_positions()\n        self.analyze_joint_velocities()\n        self.analyze_joint_efforts()\n\n    def apply_filter(self, filter_coeff, value):\n        \"\"\"Apply a simple filter to a value.\"\"\"\n        # This is a simplified implementation\n        # In practice, you would maintain the filter's internal state\n        return value  # Return unfiltered for now\n\n    def analyze_joint_positions(self):\n        \"\"\"Analyze joint position data for humanoid robot.\"\"\"\n        if not self.current_joint_state:\n            return\n\n        # Check for joint limits\n        for i, joint_name in enumerate(self.current_joint_state.name):\n            if i < len(self.current_joint_state.position):\n                pos = self.current_joint_state.position[i]\n\n                # Define joint limits (simplified)\n                if 'hip' in joint_name:\n                    limit_min, limit_max = -1.57, 1.57  # \xb190 degrees\n                elif 'knee' in joint_name:\n                    limit_min, limit_max = 0.0, 2.36  # 0 to 135 degrees\n                elif 'shoulder' in joint_name:\n                    limit_min, limit_max = -2.0, 2.0  # \xb1115 degrees\n                else:\n                    limit_min, limit_max = -3.14, 3.14  # \xb1180 degrees\n\n                if pos < limit_min or pos > limit_max:\n                    self.get_logger().warn(f'Joint {joint_name} position {pos} exceeds limits [{limit_min}, {limit_max}]')\n\n    def analyze_joint_velocities(self):\n        \"\"\"Analyze joint velocity data.\"\"\"\n        if not self.current_joint_state:\n            return\n\n        for i, joint_name in enumerate(self.current_joint_state.name):\n            if i < len(self.current_joint_state.velocity):\n                vel = self.current_joint_state.velocity[i]\n                # Check for excessive velocities\n                if abs(vel) > 10.0:  # 10 rad/s threshold\n                    self.get_logger().warn(f'Joint {joint_name} velocity {vel} is excessive')\n\n    def analyze_joint_efforts(self):\n        \"\"\"Analyze joint effort data.\"\"\"\n        if not self.current_joint_state:\n            return\n\n        for i, joint_name in enumerate(self.current_joint_state.name):\n            if i < len(self.current_joint_state.effort):\n                effort = self.current_joint_state.effort[i]\n                # Check for excessive efforts\n                if abs(effort) > 100.0:  # 100 Nm threshold\n                    self.get_logger().warn(f'Joint {joint_name} effort {effort} is excessive')\n\n    def process_imu_data(self):\n        \"\"\"Process IMU data for balance and orientation analysis.\"\"\"\n        if not self.current_imu_data:\n            return\n\n        # Extract orientation data\n        orientation = self.current_imu_data.orientation\n        angular_velocity = self.current_imu_data.angular_velocity\n        linear_acceleration = self.current_imu_data.linear_acceleration\n\n        # Calculate roll, pitch, yaw from quaternion\n        roll, pitch, yaw = self.quaternion_to_euler(\n            orientation.x, orientation.y, orientation.z, orientation.w\n        )\n\n        # Check for balance issues\n        if abs(pitch) > 0.5 or abs(roll) > 0.5:  # 28.6 degrees threshold\n            self.get_logger().warn(f'Potential balance issue: pitch={pitch:.3f}, roll={roll:.3f}')\n\n        # Store filtered IMU data\n        self.filtered_imu_data = {\n            'roll': roll,\n            'pitch': pitch,\n            'yaw': yaw,\n            'angular_velocity': [angular_velocity.x, angular_velocity.y, angular_velocity.z],\n            'linear_acceleration': [linear_acceleration.x, linear_acceleration.y, linear_acceleration.z]\n        }\n\n    def process_cmd_vel_data(self):\n        \"\"\"Process velocity command data.\"\"\"\n        if not self.current_cmd_vel:\n            return\n\n        # Check for excessive velocity commands\n        linear_speed = np.sqrt(\n            self.current_cmd_vel.linear.x**2 +\n            self.current_cmd_vel.linear.y**2 +\n            self.current_cmd_vel.linear.z**2\n        )\n\n        angular_speed = np.sqrt(\n            self.current_cmd_vel.angular.x**2 +\n            self.current_cmd_vel.angular.y**2 +\n            self.current_cmd_vel.angular.z**2\n        )\n\n        max_linear = 2.0  # 2 m/s\n        max_angular = 1.0  # 1 rad/s\n\n        if linear_speed > max_linear:\n            self.get_logger().warn(f'Linear velocity command {linear_speed:.3f} exceeds limit {max_linear}')\n\n        if angular_speed > max_angular:\n            self.get_logger().warn(f'Angular velocity command {angular_speed:.3f} exceeds limit {max_angular}')\n\n    def quaternion_to_euler(self, x, y, z, w):\n        \"\"\"Convert quaternion to Euler angles (roll, pitch, yaw).\"\"\"\n        # Roll (x-axis rotation)\n        sinr_cosp = 2 * (w * x + y * z)\n        cosr_cosp = 1 - 2 * (x * x + y * y)\n        roll = np.arctan2(sinr_cosp, cosr_cosp)\n\n        # Pitch (y-axis rotation)\n        sinp = 2 * (w * y - z * x)\n        if np.abs(sinp) >= 1:\n            pitch = np.copysign(np.pi / 2, sinp)  # Use 90 degrees if out of range\n        else:\n            pitch = np.arcsin(sinp)\n\n        # Yaw (z-axis rotation)\n        siny_cosp = 2 * (w * z + x * y)\n        cosy_cosp = 1 - 2 * (y * y + z * z)\n        yaw = np.arctan2(siny_cosp, cosy_cosp)\n\n        return roll, pitch, yaw\n\n    def get_current_state_summary(self):\n        \"\"\"Get a summary of the current robot state.\"\"\"\n        summary = {\n            'joint_state_available': self.current_joint_state is not None,\n            'imu_data_available': self.current_imu_data is not None,\n            'cmd_vel_available': self.current_cmd_vel is not None,\n            'message_counts': dict(self.message_counts),\n            'average_processing_time_ms': np.mean(self.processing_times) if self.processing_times else 0.0,\n            'joint_count': len(self.joint_names) if self.current_joint_state else 0\n        }\n\n        return summary\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = AdvancedHumanoidSubscriberNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-service-and-client-implementation-for-humanoid-robotics",children:"Advanced Service and Client Implementation for Humanoid Robotics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom example_interfaces.srv import Trigger, SetBool\nfrom std_srvs.srv import Empty\nfrom builtin_interfaces.msg import Time\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist, Vector3\nfrom std_msgs.msg import Float64MultiArray\nimport time\nimport threading\nfrom collections import deque\nimport numpy as np\nimport json\nfrom typing import Dict, List, Optional, Any\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass HumanoidServiceNode(Node):\n    \"\"\"\n    Advanced service node implementing real-time safe services for humanoid robotics.\n    Includes sophisticated state management, safety monitoring, and performance tracking.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_humanoid_service_node')\n\n        # Declare parameters for service configuration\n        self.declare_parameter('service_thread_pool_size', 4)\n        self.declare_parameter('service_timeout_sec', 5.0)\n        self.declare_parameter('enable_service_monitoring', True)\n        self.declare_parameter('max_concurrent_requests', 10)\n\n        # Get parameter values\n        self.service_thread_pool_size = self.get_parameter('service_thread_pool_size').value\n        self.service_timeout_sec = self.get_parameter('service_timeout_sec').value\n        self.enable_service_monitoring = self.get_parameter('enable_service_monitoring').value\n        self.max_concurrent_requests = self.get_parameter('max_concurrent_requests').value\n\n        # Initialize thread pool for service execution\n        self.service_executor = ThreadPoolExecutor(max_workers=self.service_thread_pool_size)\n\n        # Create services with appropriate QoS profiles\n        self.qos_services = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # Core humanoid services\n        self.calibrate_service = self.create_service(\n            Trigger,\n            'autonomous_humanoid/calibrate',\n            self.calibrate_callback,\n            qos_profile=self.qos_services\n        )\n\n        self.emergency_stop_service = self.create_service(\n            Trigger,\n            'autonomous_humanoid/emergency_stop',\n            self.emergency_stop_callback,\n            qos_profile=self.qos_services\n        )\n\n        self.reset_position_service = self.create_service(\n            Empty,\n            'autonomous_humanoid/reset_position',\n            self.reset_position_callback,\n            qos_profile=self.qos_services\n        )\n\n        self.enable_motors_service = self.create_service(\n            SetBool,\n            'autonomous_humanoid/enable_motors',\n            self.enable_motors_callback,\n            qos_profile=self.qos_services\n        )\n\n        # Advanced services for humanoid control\n        self.set_joint_positions_service = self.create_service(\n            Float64MultiArray,\n            'autonomous_humanoid/set_joint_positions',\n            self.set_joint_positions_callback,\n            qos_profile=self.qos_services\n        )\n\n        self.get_robot_state_service = self.create_service(\n            Trigger,\n            'autonomous_humanoid/get_robot_state',\n            self.get_robot_state_callback,\n            qos_profile=self.qos_services\n        )\n\n        # Initialize service state and monitoring\n        self.motors_enabled = False\n        self.calibration_state = False\n        self.emergency_stop_active = False\n        self.balance_state = {'pitch': 0.0, 'roll': 0.0, 'yaw': 0.0}\n        self.joint_states = {}\n\n        # Service statistics and monitoring\n        self.service_stats = {\n            'calibrate_calls': 0,\n            'emergency_stop_calls': 0,\n            'reset_position_calls': 0,\n            'enable_motors_calls': 0,\n            'set_joint_positions_calls': 0,\n            'get_robot_state_calls': 0,\n            'total_service_time': 0.0,\n            'service_errors': 0\n        }\n\n        # Initialize subscribers for state monitoring\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'autonomous_humanoid/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            'autonomous_humanoid/imu/data',\n            self.imu_callback,\n            10\n        )\n\n        self.get_logger().info(\n            f'Advanced Humanoid Service Node initialized with {self.service_thread_pool_size} service threads'\n        )\n\n    def joint_state_callback(self, msg: JointState):\n        \"\"\"Update internal joint state from sensor data.\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_states[name] = {\n                    'position': msg.position[i],\n                    'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                    'effort': msg.effort[i] if i < len(msg.effort) else 0.0,\n                    'timestamp': time.time()\n                }\n\n    def imu_callback(self, msg: Imu):\n        \"\"\"Update internal balance state from IMU data.\"\"\"\n        # Convert quaternion to Euler angles (simplified)\n        w, x, y, z = msg.orientation.w, msg.orientation.x, msg.orientation.y, msg.orientation.z\n\n        # Calculate roll, pitch, yaw (simplified approximation)\n        self.balance_state['roll'] = np.arctan2(2.0 * (w * x + y * z), 1.0 - 2.0 * (x * x + y * y))\n        self.balance_state['pitch'] = np.arcsin(2.0 * (w * y - z * x))\n        self.balance_state['yaw'] = np.arctan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (y * y + z * z))\n\n    def calibrate_callback(self, request, response):\n        \"\"\"Calibrate all humanoid joints with safety checks.\"\"\"\n        start_time = time.time()\n        self.service_stats['calibrate_calls'] += 1\n\n        try:\n            self.get_logger().info('Starting calibration procedure with safety checks')\n\n            # Safety checks before calibration\n            if self.emergency_stop_active:\n                raise Exception('Cannot calibrate while emergency stop is active')\n\n            if abs(self.balance_state['pitch']) > 0.5 or abs(self.balance_state['roll']) > 0.5:\n                raise Exception('Robot not in safe balance state for calibration')\n\n            # Activate safety mode during calibration\n            self.emergency_stop_active = True\n            self.motors_enabled = False\n\n            # Perform calibration steps\n            self.get_logger().info('Calibrating joint positions...')\n            self._calibrate_joints()\n\n            self.get_logger().info('Calibrating sensors...')\n            self._calibrate_sensors()\n\n            # Update calibration state\n            self.calibration_state = True\n\n            # Restore normal operation\n            self.emergency_stop_active = False\n            self.motors_enabled = True\n\n            response.success = True\n            response.message = 'Calibration completed successfully'\n\n            self.get_logger().info('Calibration completed successfully')\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Calibration failed: {str(e)}'\n            self.get_logger().error(f'Calibration error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def _calibrate_joints(self):\n        \"\"\"Internal method to calibrate all joints.\"\"\"\n        # In a real implementation, this would interface with motor controllers\n        # to move each joint to its calibration position\n        for joint_name, joint_data in self.joint_states.items():\n            # Simulate calibration movement\n            time.sleep(0.05)  # Simulate movement time\n            self.get_logger().debug(f'Calibrated joint: {joint_name}')\n\n    def _calibrate_sensors(self):\n        \"\"\"Internal method to calibrate sensors.\"\"\"\n        # In a real implementation, this would perform sensor calibration procedures\n        time.sleep(0.1)  # Simulate calibration time\n        self.get_logger().debug('Sensors calibrated')\n\n    def emergency_stop_callback(self, request, response):\n        \"\"\"Activate emergency stop with safety monitoring.\"\"\"\n        start_time = time.time()\n        self.service_stats['emergency_stop_calls'] += 1\n        self.get_logger().warn('EMERGENCY STOP ACTIVATED')\n\n        try:\n            # Stop all motor movements immediately\n            self.emergency_stop_active = True\n            self.motors_enabled = False\n\n            # Log the emergency stop with state information\n            self.get_logger().info(\n                f'Emergency stop activated. Balance state: pitch={self.balance_state[\"pitch\"]:.3f}, '\n                f'roll={self.balance_state[\"roll\"]:.3f}'\n            )\n\n            response.success = True\n            response.message = 'Emergency stop activated'\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Emergency stop failed: {str(e)}'\n            self.get_logger().error(f'Emergency stop error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def reset_position_callback(self, request, response):\n        \"\"\"Reset humanoid to default position with safety checks.\"\"\"\n        start_time = time.time()\n        self.service_stats['reset_position_calls'] += 1\n        self.get_logger().info('Resetting humanoid to default position')\n\n        try:\n            # Safety checks\n            if not self.motors_enabled:\n                raise Exception('Motors not enabled - cannot reset position')\n\n            if self.emergency_stop_active:\n                raise Exception('Emergency stop active - cannot reset position')\n\n            # Calculate safe reset position based on current balance\n            if abs(self.balance_state['pitch']) > 0.5 or abs(self.balance_state['roll']) > 0.5:\n                raise Exception('Robot is in unstable position - cannot safely reset')\n\n            # Move to default position\n            default_positions = self._calculate_safe_default_position()\n            self._move_to_position(default_positions)\n\n            response.success = True\n            response.message = 'Position reset completed safely'\n\n            self.get_logger().info('Position reset completed successfully')\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Position reset failed: {str(e)}'\n            self.get_logger().error(f'Position reset error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def _calculate_safe_default_position(self) -> List[float]:\n        \"\"\"Calculate a safe default position based on current robot state.\"\"\"\n        # This would implement a safe standing position based on the robot's kinematic structure\n        # For now, return a simple default position\n        default_positions = []\n        for joint_name in sorted(self.joint_states.keys()):\n            # Calculate safe position based on joint type and current state\n            default_positions.append(0.0)  # Simplified default\n\n        return default_positions\n\n    def _move_to_position(self, positions: List[float]):\n        \"\"\"Internal method to move joints to specified positions.\"\"\"\n        # In a real implementation, this would interface with the motion controller\n        # For simulation, just sleep for the movement time\n        movement_time = 1.0  # seconds\n        time.sleep(movement_time)\n        self.get_logger().debug(f'Moved to position with {len(positions)} joints')\n\n    def enable_motors_callback(self, request, response):\n        \"\"\"Enable or disable motors with comprehensive safety checks.\"\"\"\n        start_time = time.time()\n        self.service_stats['enable_motors_calls'] += 1\n        enable = request.data\n        self.get_logger().info(f'{\"Enabling\" if enable else \"Disabling\"} motors')\n\n        try:\n            if enable:\n                # Comprehensive safety checks before enabling\n                if self.emergency_stop_active:\n                    raise Exception('Cannot enable motors while emergency stop is active')\n\n                if abs(self.balance_state['pitch']) > 0.7 or abs(self.balance_state['roll']) > 0.7:\n                    raise Exception('Robot not in safe balance state for motor enable')\n\n                # Check for joint limit violations\n                if self._has_joint_limit_violations():\n                    raise Exception('Joint limit violations detected - cannot enable motors')\n\n                # Enable motors\n                self.motors_enabled = True\n                response.success = True\n                response.message = 'Motors enabled successfully'\n\n                self.get_logger().info('Motors enabled safely')\n            else:\n                # Disable motors\n                self.motors_enabled = False\n                response.success = True\n                response.message = 'Motors disabled successfully'\n\n                self.get_logger().info('Motors disabled')\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Motor control failed: {str(e)}'\n            self.get_logger().error(f'Motor control error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def _has_joint_limit_violations(self) -> bool:\n        \"\"\"Check for joint limit violations.\"\"\"\n        # In a real implementation, this would check joint positions against limits\n        return False  # Simplified for now\n\n    def set_joint_positions_callback(self, request, response):\n        \"\"\"Set joint positions with trajectory planning and safety checks.\"\"\"\n        start_time = time.time()\n        self.service_stats['set_joint_positions_calls'] += 1\n\n        try:\n            target_positions = list(request.data)\n\n            # Safety checks\n            if not self.motors_enabled:\n                raise Exception('Motors not enabled - cannot set joint positions')\n\n            if self.emergency_stop_active:\n                raise Exception('Emergency stop active - cannot set joint positions')\n\n            # Validate joint position limits\n            if not self._validate_joint_positions(target_positions):\n                raise Exception('Target positions exceed joint limits')\n\n            # Plan smooth trajectory\n            trajectory = self._plan_smooth_trajectory(target_positions)\n\n            # Execute trajectory\n            self._execute_trajectory(trajectory)\n\n            response.success = True\n            response.message = f'Set {len(target_positions)} joint positions successfully'\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Set joint positions failed: {str(e)}'\n            self.get_logger().error(f'Set joint positions error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def _validate_joint_positions(self, positions: List[float]) -> bool:\n        \"\"\"Validate that joint positions are within limits.\"\"\"\n        # In a real implementation, this would check against actual joint limits\n        for pos in positions:\n            if abs(pos) > 3.14:  # Basic check for extreme positions\n                return False\n        return True\n\n    def _plan_smooth_trajectory(self, target_positions: List[float]) -> List[List[float]]:\n        \"\"\"Plan a smooth trajectory to reach target positions.\"\"\"\n        # Simplified trajectory planning - in reality this would use more sophisticated algorithms\n        current_positions = [self.joint_states.get(name, {}).get('position', 0.0)\n                            for name in sorted(self.joint_states.keys())]\n\n        # Create 10 intermediate points for smooth movement\n        trajectory = []\n        for i in range(10):\n            fraction = i / 9.0\n            intermediate_positions = [\n                current + fraction * (target - current)\n                for current, target in zip(current_positions, target_positions)\n            ]\n            trajectory.append(intermediate_positions)\n\n        return trajectory\n\n    def _execute_trajectory(self, trajectory: List[List[float]]):\n        \"\"\"Execute a planned trajectory.\"\"\"\n        for positions in trajectory:\n            # In a real implementation, this would send commands to motor controllers\n            time.sleep(0.05)  # Simulate execution time\n\n    def get_robot_state_callback(self, request, response):\n        \"\"\"Get comprehensive robot state information.\"\"\"\n        start_time = time.time()\n        self.service_stats['get_robot_state_calls'] += 1\n\n        try:\n            # Compile comprehensive robot state\n            robot_state = {\n                'motors_enabled': self.motors_enabled,\n                'calibration_state': self.calibration_state,\n                'emergency_stop_active': self.emergency_stop_active,\n                'balance_state': self.balance_state.copy(),\n                'joint_states': {name: data.copy() for name, data in self.joint_states.items()},\n                'timestamp': time.time(),\n                'service_stats': self.service_stats.copy()\n            }\n\n            # Encode as JSON string in the response\n            response.success = True\n            response.message = json.dumps(robot_state, indent=2)\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Get robot state failed: {str(e)}'\n            self.get_logger().error(f'Get robot state error: {str(e)}')\n            self.service_stats['service_errors'] += 1\n\n        end_time = time.time()\n        self.service_stats['total_service_time'] += (end_time - start_time)\n        return response\n\n    def get_service_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive service statistics.\"\"\"\n        total_calls = sum([\n            self.service_stats['calibrate_calls'],\n            self.service_stats['emergency_stop_calls'],\n            self.service_stats['reset_position_calls'],\n            self.service_stats['enable_motors_calls'],\n            self.service_stats['set_joint_positions_calls'],\n            self.service_stats['get_robot_state_calls']\n        ])\n\n        avg_time = self.service_stats['total_service_time'] / total_calls if total_calls > 0 else 0\n\n        return {\n            'calibrate_calls': self.service_stats['calibrate_calls'],\n            'emergency_stop_calls': self.service_stats['emergency_stop_calls'],\n            'reset_position_calls': self.service_stats['reset_position_calls'],\n            'enable_motors_calls': self.service_stats['enable_motors_calls'],\n            'set_joint_positions_calls': self.service_stats['set_joint_positions_calls'],\n            'get_robot_state_calls': self.service_stats['get_robot_state_calls'],\n            'total_service_calls': total_calls,\n            'total_errors': self.service_stats['service_errors'],\n            'average_response_time_ms': avg_time * 1000,\n            'error_rate_percent': (self.service_stats['service_errors'] / total_calls * 100) if total_calls > 0 else 0\n        }\n\nclass AdvancedHumanoidClientNode(Node):\n    \"\"\"\n    Advanced client node demonstrating sophisticated service interaction patterns for humanoid robotics.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_humanoid_client_node')\n\n        # Create clients for all humanoid services\n        self.clients = {\n            'calibrate': self.create_client(Trigger, 'autonomous_humanoid/calibrate'),\n            'emergency_stop': self.create_client(Trigger, 'autonomous_humanoid/emergency_stop'),\n            'reset_position': self.create_client(Empty, 'autonomous_humanoid/reset_position'),\n            'enable_motors': self.create_client(SetBool, 'autonomous_humanoid/enable_motors'),\n            'set_joint_positions': self.create_client(Float64MultiArray, 'autonomous_humanoid/set_joint_positions'),\n            'get_robot_state': self.create_client(Trigger, 'autonomous_humanoid/get_robot_state')\n        }\n\n        # Wait for all services to be available\n        self.get_logger().info('Waiting for all humanoid services to become available...')\n        for service_name, client in self.clients.items():\n            while not client.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info(f'{service_name} service not available, waiting...')\n\n        self.get_logger().info('All humanoid services are available')\n\n        # Create timer for periodic service calls\n        self.service_test_timer = self.create_timer(10.0, self.run_system_tests)\n\n        # Performance monitoring\n        self.request_times = deque(maxlen=100)\n        self.error_count = 0\n\n        self.get_logger().info('Advanced Humanoid Client Node initialized and connected to all services')\n\n    async def call_service_async(self, service_name: str, request, timeout_sec: float = 5.0) -> Optional[Any]:\n        \"\"\"Asynchronously call a service with timeout.\"\"\"\n        client = self.clients[service_name]\n        start_time = time.time()\n\n        try:\n            future = client.call_async(request)\n            result = await asyncio.wait_for(asyncio.wrap_future(future), timeout=timeout_sec)\n\n            response_time = time.time() - start_time\n            self.request_times.append(response_time)\n\n            self.get_logger().debug(f'{service_name} service call completed in {response_time:.3f}s')\n            return result\n\n        except asyncio.TimeoutError:\n            self.get_logger().error(f'{service_name} service call timed out after {timeout_sec}s')\n            self.error_count += 1\n            return None\n        except Exception as e:\n            self.get_logger().error(f'{service_name} service call failed: {str(e)}')\n            self.error_count += 1\n            return None\n\n    def run_system_tests(self):\n        \"\"\"Run comprehensive system tests calling various services.\"\"\"\n        self.get_logger().info('Running humanoid system tests...')\n\n        # Test 1: Get current robot state\n        self.test_get_robot_state()\n\n        # Test 2: Enable motors (if not already enabled)\n        self.test_enable_motors()\n\n        # Test 3: Reset position (if in safe state)\n        self.test_reset_position()\n\n        # Test 4: Set some joint positions\n        self.test_set_joint_positions()\n\n        # Test 5: Get robot state again to verify changes\n        self.test_get_robot_state()\n\n        # Log performance statistics\n        self.log_performance_stats()\n\n    def test_get_robot_state(self):\n        \"\"\"Test getting robot state.\"\"\"\n        request = Trigger.Request()\n        future = self.clients['get_robot_state'].call_async(request)\n\n        # Handle response in a callback to avoid blocking\n        future.add_done_callback(self.handle_robot_state_response)\n\n    def handle_robot_state_response(self, future):\n        \"\"\"Handle robot state response.\"\"\"\n        try:\n            response = future.result()\n            if response.success:\n                state_data = json.loads(response.message)\n                self.get_logger().info(f'Robot state: Motors enabled={state_data[\"motors_enabled\"]}, '\n                                     f'Balance pitch={state_data[\"balance_state\"][\"pitch\"]:.3f}')\n            else:\n                self.get_logger().error(f'Get robot state failed: {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Error processing robot state response: {str(e)}')\n\n    def test_enable_motors(self):\n        \"\"\"Test enabling motors.\"\"\"\n        request = SetBool.Request()\n        request.data = True\n        future = self.clients['enable_motors'].call_async(request)\n        future.add_done_callback(lambda f: self.handle_enable_motors_response(f, \"enable\"))\n\n    def test_reset_position(self):\n        \"\"\"Test resetting position.\"\"\"\n        # Only reset if robot is in a safe state\n        request = Empty.Request()\n        future = self.clients['reset_position'].call_async(request)\n        future.add_done_callback(lambda f: self.handle_simple_response(f, \"reset position\"))\n\n    def test_set_joint_positions(self):\n        \"\"\"Test setting joint positions.\"\"\"\n        # Send a simple joint position command\n        request = Float64MultiArray.Request()\n        # Send zeros as a safe default (would be actual positions in real use)\n        request.data = [0.0] * 12  # 12 joints\n        future = self.clients['set_joint_positions'].call_async(request)\n        future.add_done_callback(lambda f: self.handle_simple_response(f, \"set joint positions\"))\n\n    def handle_enable_motors_response(self, future, action_name):\n        \"\"\"Handle enable/disable motors response.\"\"\"\n        try:\n            response = future.result()\n            if response.success:\n                self.get_logger().info(f'Motors {action_name}d successfully')\n            else:\n                self.get_logger().error(f'Failed to {action_name} motors: {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Error processing {action_name} response: {str(e)}')\n\n    def handle_simple_response(self, future, action_name):\n        \"\"\"Handle simple service response.\"\"\"\n        try:\n            response = future.result()\n            if response.success:\n                self.get_logger().info(f'{action_name.title()} completed successfully')\n            else:\n                self.get_logger().error(f'{action_name.title()} failed: {response.message}')\n        except Exception as e:\n            self.get_logger().error(f'Error processing {action_name} response: {str(e)}')\n\n    def log_performance_stats(self):\n        \"\"\"Log performance statistics.\"\"\"\n        if self.request_times:\n            avg_time = sum(self.request_times) / len(self.request_times)\n            max_time = max(self.request_times)\n            min_time = min(self.request_times)\n\n            self.get_logger().info(\n                f'Service performance - Avg: {avg_time*1000:.1f}ms, '\n                f'Max: {max_time*1000:.1f}ms, Min: {min_time*1000:.1f}ms, '\n                f'Errors: {self.error_count}'\n            )\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Create both service and client nodes\n    service_node = AdvancedHumanoidServiceNode()\n    client_node = AdvancedHumanoidClientNode()\n\n    # Create multi-threaded executor to run both nodes\n    executor = rclpy.executors.MultiThreadedExecutor(num_threads=4)\n    executor.add_node(service_node)\n    executor.add_node(client_node)\n\n    try:\n        service_node.get_logger().info('Starting humanoid service and client nodes...')\n        executor.spin()\n    except KeyboardInterrupt:\n        service_node.get_logger().info('Service node interrupted by user')\n        client_node.get_logger().info('Client node interrupted by user')\n    finally:\n        service_node.destroy_node()\n        client_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-parameter-management-with-dynamic-reconfiguration",children:"Advanced Parameter Management with Dynamic Reconfiguration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom std_msgs.msg import Float64, String\nfrom geometry_msgs.msg import Vector3\nimport json\nimport time\nfrom typing import List, Dict, Any, Optional\nimport threading\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ControlMode(Enum):\n    \"\"\"Enumeration of control modes for humanoid robot.\"\"\"\n    IDLE = \"idle\"\n    POSITION_CONTROL = \"position_control\"\n    VELOCITY_CONTROL = \"velocity_control\"\n    TORQUE_CONTROL = \"torque_control\"\n    IMPEDANCE_CONTROL = \"impedance_control\"\n    TRAJECTORY_FOLLOWING = \"trajectory_following\"\n\n@dataclass\nclass GaitParameters:\n    \"\"\"Data class for walking gait parameters.\"\"\"\n    step_height: float = 0.1\n    step_length: float = 0.3\n    step_duration: float = 1.0\n    stance_phase_ratio: float = 0.6\n    swing_phase_ratio: float = 0.4\n    max_step_frequency: float = 2.0\n\n@dataclass\nclass BalanceParameters:\n    \"\"\"Data class for balance control parameters.\"\"\"\n    com_height: float = 0.8\n    com_offset_x: float = 0.0\n    com_offset_y: float = 0.0\n    balance_gain_p: float = 10.0\n    balance_gain_i: float = 1.0\n    balance_gain_d: float = 0.5\n    max_lean_angle: float = 0.3\n\nclass AdvancedHumanoidParameterNode(Node):\n    \"\"\"\n    Advanced parameter node with dynamic reconfiguration for humanoid robotics.\n    Features include parameter validation, inter-parameter dependencies, and runtime updates.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('advanced_humanoid_parameter_node')\n\n        # Declare complex parameters with validators\n        self.declare_parameter('control.frequency', 100,\n                              ParameterDescriptor(description='Control loop frequency in Hz',\n                                                integer_range=[{'from_value': 10, 'to_value': 1000, 'step': 10}]))\n        self.declare_parameter('control.max_velocity', 1.0,\n                              ParameterDescriptor(description='Maximum joint velocity in rad/s',\n                                                double_range=[{'from_value': 0.1, 'to_value': 10.0, 'step': 0.1}]))\n        self.declare_parameter('control.max_acceleration', 5.0,\n                              ParameterDescriptor(description='Maximum joint acceleration in rad/s^2',\n                                                double_range=[{'from_value': 0.5, 'to_value': 50.0, 'step': 0.1}]))\n        self.declare_parameter('safety.timeout', 1.0,\n                              ParameterDescriptor(description='Safety timeout in seconds',\n                                                double_range=[{'from_value': 0.1, 'to_value': 10.0, 'step': 0.1}]))\n        self.declare_parameter('balance.threshold', 0.1,\n                              ParameterDescriptor(description='Balance threshold in radians',\n                                                double_range=[{'from_value': 0.01, 'to_value': 1.0, 'step': 0.01}]))\n        self.declare_parameter('robot.name', 'autonomous_humanoid',\n                              ParameterDescriptor(description='Name of the robot'))\n\n        # Declare array parameters for joint limits\n        self.declare_parameter('joints.limits.position',\n                              [1.57, 1.57, 0.78, 1.57, 1.57, 0.78],  # Example limits\n                              ParameterDescriptor(description='Joint position limits (rad)'))\n\n        # Declare complex gait parameters\n        self.declare_parameter('gait.step_height', 0.1,\n                              ParameterDescriptor(description='Walking step height (m)',\n                                                double_range=[{'from_value': 0.01, 'to_value': 0.5, 'step': 0.01}]))\n        self.declare_parameter('gait.step_length', 0.3,\n                              ParameterDescriptor(description='Walking step length (m)',\n                                                double_range=[{'from_value': 0.05, 'to_value': 1.0, 'step': 0.01}]))\n        self.declare_parameter('gait.step_duration', 1.0,\n                              ParameterDescriptor(description='Walking step duration (s)',\n                                                double_range=[{'from_value': 0.1, 'to_value': 5.0, 'step': 0.01}]))\n        self.declare_parameter('gait.stance_ratio', 0.6,\n                              ParameterDescriptor(description='Stance phase ratio',\n                                                double_range=[{'from_value': 0.1, 'to_value': 0.9, 'step': 0.01}]))\n\n        # Declare balance control parameters\n        self.declare_parameter('balance.com_height', 0.8,\n                              ParameterDescriptor(description='Center of mass height (m)',\n                                                double_range=[{'from_value': 0.5, 'to_value': 1.5, 'step': 0.01}]))\n        self.declare_parameter('balance.gain_p', 10.0,\n                              ParameterDescriptor(description='Balance control P gain',\n                                                double_range=[{'from_value': 0.1, 'to_value': 100.0, 'step': 0.1}]))\n        self.declare_parameter('balance.gain_i', 1.0,\n                              ParameterDescriptor(description='Balance control I gain',\n                                                double_range=[{'from_value': 0.0, 'to_value': 10.0, 'step': 0.01}]))\n        self.declare_parameter('balance.gain_d', 0.5,\n                              ParameterDescriptor(description='Balance control D gain',\n                                                double_range=[{'from_value': 0.0, 'to_value': 10.0, 'step': 0.01}]))\n\n        # Create publisher for parameter change notifications\n        self.param_change_pub = self.create_publisher(\n            String,\n            'parameter_changes',\n            QoSProfile(depth=20, reliability=ReliabilityPolicy.RELIABLE)\n        )\n\n        # Set up parameter callback with validation\n        self.set_parameters_callback(self.parameters_callback)\n\n        # Initialize parameter values\n        self.update_parameter_values()\n\n        # Create timer for parameter validation\n        self.param_validation_timer = self.create_timer(2.0, self.validate_parameters)\n\n        # Parameter change history for rollback capability\n        self.param_history = deque(maxlen=50)\n\n        # Lock for thread-safe parameter access\n        self.param_lock = threading.Lock()\n\n        self.get_logger().info('Advanced Humanoid Parameter Node initialized with validation and monitoring')\n\n    def parameters_callback(self, params):\n        \"\"\"\n        Callback for parameter changes with comprehensive validation.\n        \"\"\"\n        start_time = time.time()\n        successful_params = []\n        failed_params = []\n\n        with self.param_lock:\n            for param in params:\n                validation_result = self.validate_parameter(param)\n\n                if validation_result.is_valid:\n                    successful_params.append(param)\n\n                    # Store in history for potential rollback\n                    self.param_history.append({\n                        'parameter': param.name,\n                        'old_value': self.get_parameter(param.name).value if self.has_parameter(param.name) else None,\n                        'new_value': param.value,\n                        'timestamp': time.time()\n                    })\n                else:\n                    failed_params.append(f'{param.name}: {validation_result.error_message}')\n\n            # Apply successful changes\n            if successful_params:\n                for param in successful_params:\n                    self.get_logger().info(f'Parameter {param.name} changed to {param.value}')\n\n                    # Notify about parameter change\n                    self.notify_parameter_change(param)\n\n        # Calculate validation time\n        validation_time = time.time() - start_time\n\n        # Log performance if validation took too long\n        if validation_time > 0.01:  # 10ms threshold\n            self.get_logger().warn(f'Parameter validation took {validation_time*1000:.2f}ms')\n\n        return SetParametersResult(successful=(len(failed_params) == 0))\n\n    def validate_parameter(self, param):\n        \"\"\"Validate a single parameter with context-aware rules.\"\"\"\n        class ValidationResult:\n            def __init__(self, is_valid=True, error_message=\"\"):\n                self.is_valid = is_valid\n                self.error_message = error_message\n\n        # Validate control frequency\n        if param.name == 'control.frequency':\n            if not isinstance(param.value, int) and not isinstance(param.value, float):\n                return ValidationResult(False, \"Control frequency must be numeric\")\n            if param.value < 10 or param.value > 1000:\n                return ValidationResult(False, \"Control frequency must be between 10-1000 Hz\")\n            return ValidationResult(True)\n\n        # Validate maximum velocity\n        elif param.name == 'control.max_velocity':\n            if not isinstance(param.value, (int, float)):\n                return ValidationResult(False, \"Max velocity must be numeric\")\n            if param.value <= 0 or param.value > 10.0:\n                return ValidationResult(False, \"Max velocity must be between 0.1-10.0 rad/s\")\n            return ValidationResult(True)\n\n        # Validate maximum acceleration\n        elif param.name == 'control.max_acceleration':\n            if not isinstance(param.value, (int, float)):\n                return ValidationResult(False, \"Max acceleration must be numeric\")\n            if param.value <= 0 or param.value > 100.0:\n                return ValidationResult(False, \"Max acceleration must be between 0.5-100.0 rad/s\xb2\")\n            return ValidationResult(True)\n\n        # Validate balance threshold\n        elif param.name == 'balance.threshold':\n            if not isinstance(param.value, (int, float)):\n                return ValidationResult(False, \"Balance threshold must be numeric\")\n            if param.value <= 0 or param.value > 1.57:  # Max 90 degrees\n                return ValidationResult(False, \"Balance threshold must be between 0.01-1.57 rad\")\n            return ValidationResult(True)\n\n        # Validate gait parameters\n        elif param.name.startswith('gait.'):\n            if not isinstance(param.value, (int, float)):\n                return ValidationResult(False, f\"{param.name} must be numeric\")\n\n            if param.name == 'gait.step_height':\n                if param.value < 0.01 or param.value > 0.5:\n                    return ValidationResult(False, \"Step height must be between 0.01-0.5m\")\n            elif param.name == 'gait.step_length':\n                if param.value < 0.05 or param.value > 1.0:\n                    return ValidationResult(False, \"Step length must be between 0.05-1.0m\")\n            elif param.name == 'gait.step_duration':\n                if param.value < 0.1 or param.value > 5.0:\n                    return ValidationResult(False, \"Step duration must be between 0.1-5.0s\")\n            elif param.name == 'gait.stance_ratio':\n                if param.value < 0.1 or param.value > 0.9:\n                    return ValidationResult(False, \"Stance ratio must be between 0.1-0.9\")\n\n            return ValidationResult(True)\n\n        # Validate balance parameters\n        elif param.name.startswith('balance.'):\n            if not isinstance(param.value, (int, float)):\n                return ValidationResult(False, f\"{param.name} must be numeric\")\n\n            if param.name == 'balance.com_height':\n                if param.value < 0.5 or param.value > 1.5:\n                    return ValidationResult(False, \"COM height must be between 0.5-1.5m\")\n            elif param.name == 'balance.gain_p':\n                if param.value < 0.1 or param.value > 100.0:\n                    return ValidationResult(False, \"P gain must be between 0.1-100.0\")\n            elif param.name == 'balance.gain_i':\n                if param.value < 0.0 or param.value > 10.0:\n                    return ValidationResult(False, \"I gain must be between 0.0-10.0\")\n            elif param.name == 'balance.gain_d':\n                if param.value < 0.0 or param.value > 10.0:\n                    return ValidationResult(False, \"D gain must be between 0.0-10.0\")\n\n            return ValidationResult(True)\n\n        # For other parameters, accept them\n        return ValidationResult(True)\n\n    def notify_parameter_change(self, param):\n        \"\"\"Notify about parameter changes via publisher.\"\"\"\n        change_msg = String()\n        change_msg.data = json.dumps({\n            'parameter': param.name,\n            'value': param.value,\n            'timestamp': time.time(),\n            'node': self.get_name()\n        })\n        self.param_change_pub.publish(change_msg)\n\n    def update_parameter_values(self):\n        \"\"\"Update internal variables from parameter values.\"\"\"\n        with self.param_lock:\n            self.control_frequency = self.get_parameter('control.frequency').value\n            self.max_velocity = self.get_parameter('control.max_velocity').value\n            self.max_acceleration = self.get_parameter('control.max_acceleration').value\n            self.safety_timeout = self.get_parameter('safety.timeout').value\n            self.balance_threshold = self.get_parameter('balance.threshold').value\n            self.robot_name = self.get_parameter('robot.name').value\n            self.joint_limits = self.get_parameter('joints.limits.position').value\n\n            # Update gait parameters\n            self.gait_params = GaitParameters(\n                step_height=self.get_parameter('gait.step_height').value,\n                step_length=self.get_parameter('gait.step_length').value,\n                step_duration=self.get_parameter('gait.step_duration').value,\n                stance_phase_ratio=self.get_parameter('gait.stance_ratio').value,\n                swing_phase_ratio=1.0 - self.get_parameter('gait.stance_ratio').value\n            )\n\n            # Update balance parameters\n            self.balance_params = BalanceParameters(\n                com_height=self.get_parameter('balance.com_height').value,\n                balance_gain_p=self.get_parameter('balance.gain_p').value,\n                balance_gain_i=self.get_parameter('balance.gain_i').value,\n                balance_gain_d=self.get_parameter('balance.gain_d').value\n            )\n\n    def validate_parameters(self):\n        \"\"\"Periodically validate parameter consistency and relationships.\"\"\"\n        with self.param_lock:\n            # Check for parameter consistency\n            if (self.gait_params.step_duration <= 0 or\n                self.gait_params.step_length / self.gait_params.step_duration > 2.0):  # Max speed check\n                self.get_logger().warn(\n                    f'Gait parameters may result in excessive speed: '\n                    f'{self.gait_params.step_length/self.gait_params.step_duration:.2f} m/s'\n                )\n\n            # Check balance control gains\n            total_gain = self.balance_params.balance_gain_p + self.balance_params.balance_gain_i + self.balance_params.balance_gain_d\n            if total_gain > 200.0:\n                self.get_logger().warn(f'High balance control gains may cause instability: total={total_gain}')\n\n    def get_current_configuration(self) -> Dict[str, Any]:\n        \"\"\"Get current configuration as a comprehensive dictionary.\"\"\"\n        with self.param_lock:\n            return {\n                'control': {\n                    'frequency': self.control_frequency,\n                    'max_velocity': self.max_velocity,\n                    'max_acceleration': self.max_acceleration,\n                    'safety_timeout': self.safety_timeout\n                },\n                'balance': {\n                    'threshold': self.balance_threshold,\n                    'parameters': {\n                        'com_height': self.balance_params.com_height,\n                        'com_offset_x': self.balance_params.com_offset_x,\n                        'com_offset_y': self.balance_params.com_offset_y,\n                        'gain_p': self.balance_params.balance_gain_p,\n                        'gain_i': self.balance_params.balance_gain_i,\n                        'gain_d': self.balance_params.balance_gain_d,\n                        'max_lean_angle': self.balance_params.max_lean_angle\n                    }\n                },\n                'gait': {\n                    'step_height': self.gait_params.step_height,\n                    'step_length': self.gait_params.step_length,\n                    'step_duration': self.gait_params.step_duration,\n                    'stance_phase_ratio': self.gait_params.stance_phase_ratio,\n                    'swing_phase_ratio': self.gait_params.swing_phase_ratio,\n                    'max_step_frequency': self.gait_params.max_step_frequency\n                },\n                'robot': {\n                    'name': self.robot_name,\n                    'joint_limits': self.joint_limits\n                },\n                'system': {\n                    'parameter_count': len(self._parameters),\n                    'history_size': len(self.param_history)\n                }\n            }\n\n    def save_configuration(self, file_path: str):\n        \"\"\"Save current configuration to a file.\"\"\"\n        config = self.get_current_configuration()\n        with open(file_path, 'w') as f:\n            json.dump(config, f, indent=2)\n        self.get_logger().info(f'Configuration saved to {file_path}')\n\n    def load_configuration(self, file_path: str):\n        \"\"\"Load configuration from a file and update parameters.\"\"\"\n        try:\n            with open(file_path, 'r') as f:\n                config = json.load(f)\n\n            # Update parameters from loaded configuration\n            updates = []\n            updates.append(Parameter('control.frequency', Parameter.Type.INTEGER, config['control']['frequency']))\n            updates.append(Parameter('control.max_velocity', Parameter.Type.DOUBLE, config['control']['max_velocity']))\n            updates.append(Parameter('control.max_acceleration', Parameter.Type.DOUBLE, config['control']['max_acceleration']))\n            updates.append(Parameter('safety.timeout', Parameter.Type.DOUBLE, config['control']['safety_timeout']))\n            updates.append(Parameter('balance.threshold', Parameter.Type.DOUBLE, config['balance']['threshold']))\n\n            # Update gait parameters\n            updates.append(Parameter('gait.step_height', Parameter.Type.DOUBLE, config['gait']['step_height']))\n            updates.append(Parameter('gait.step_length', Parameter.Type.DOUBLE, config['gait']['step_length']))\n            updates.append(Parameter('gait.step_duration', Parameter.Type.DOUBLE, config['gait']['step_duration']))\n            updates.append(Parameter('gait.stance_ratio', Parameter.Type.DOUBLE, config['gait']['stance_phase_ratio']))\n\n            # Update balance parameters\n            updates.append(Parameter('balance.com_height', Parameter.Type.DOUBLE, config['balance']['parameters']['com_height']))\n            updates.append(Parameter('balance.gain_p', Parameter.Type.DOUBLE, config['balance']['parameters']['gain_p']))\n            updates.append(Parameter('balance.gain_i', Parameter.Type.DOUBLE, config['balance']['parameters']['gain_i']))\n            updates.append(Parameter('balance.gain_d', Parameter.Type.DOUBLE, config['balance']['parameters']['gain_d']))\n\n            # Apply updates\n            self.set_parameters(updates)\n\n            self.get_logger().info(f'Configuration loaded from {file_path}')\n\n        except FileNotFoundError:\n            self.get_logger().error(f'Configuration file not found: {file_path}')\n        except json.JSONDecodeError:\n            self.get_logger().error(f'Invalid JSON in configuration file: {file_path}')\n        except KeyError as e:\n            self.get_logger().error(f'Missing key in configuration file: {str(e)}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = AdvancedHumanoidParameterNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Parameter node interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-nvidia-isaac-sim-for-humanoid-robotics",children:"Integration with NVIDIA Isaac Sim for Humanoid Robotics"}),"\n",(0,i.jsx)(n.p,{children:"When developing humanoid robots, simulation is crucial for testing and validation. NVIDIA Isaac Sim provides advanced physics simulation capabilities that are essential for humanoid robotics development. Here are the key parameters and configurations for Isaac Sim setup:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "isaac_sim_config": {\n    "simulation_settings": {\n      "physics_engine": "PhysX",\n      "gravity": [0.0, 0.0, -9.81],\n      "timestep": 0.001,\n      "substeps": 1,\n      "solver_type": "TGS",\n      "solver_iterations": 4,\n      "collision_margin": 0.001,\n      "contact_offset": 0.02\n    },\n    "robot_settings": {\n      "robot_name": "autonomous_humanoid",\n      "urdf_path": "/assets/robots/humanoid.urdf",\n      "scale": [1.0, 1.0, 1.0],\n      "initial_position": [0.0, 0.0, 1.0],\n      "initial_orientation": [0.0, 0.0, 0.0, 1.0],\n      "joints": {\n        "left_hip_yaw_joint": {\n          "type": "revolute",\n          "limits": {"lower": -0.5, "upper": 0.5, "effort": 200.0, "velocity": 3.0},\n          "damping": 0.5,\n          "friction": 0.0\n        },\n        "left_hip_roll_joint": {\n          "type": "revolute",\n          "limits": {"lower": -0.5, "upper": 0.5, "effort": 200.0, "velocity": 3.0},\n          "damping": 0.5,\n          "friction": 0.0\n        },\n        "left_hip_pitch_joint": {\n          "type": "revolute",\n          "limits": {"lower": -1.57, "upper": 1.57, "effort": 200.0, "velocity": 3.0},\n          "damping": 0.5,\n          "friction": 0.0\n        },\n        "left_knee_joint": {\n          "type": "revolute",\n          "limits": {"lower": 0.0, "upper": 2.36, "effort": 200.0, "velocity": 3.0},\n          "damping": 0.4,\n          "friction": 0.0\n        },\n        "left_ankle_pitch_joint": {\n          "type": "revolute",\n          "limits": {"lower": -0.5, "upper": 0.5, "effort": 100.0, "velocity": 3.0},\n          "damping": 0.2,\n          "friction": 0.0\n        },\n        "left_ankle_roll_joint": {\n          "type": "revolute",\n          "limits": {"lower": -0.5, "upper": 0.5, "effort": 100.0, "velocity": 3.0},\n          "damping": 0.2,\n          "friction": 0.0\n        }\n      }\n    },\n    "sensor_settings": {\n      "imu": {\n        "position": [0.0, 0.0, 0.3],\n        "orientation": [0.0, 0.0, 0.0, 1.0],\n        "linear_acceleration_noise_density": 0.01,\n        "angular_velocity_noise_density": 0.001,\n        "linear_acceleration_random_walk": 0.001,\n        "angular_velocity_random_walk": 0.0001\n      },\n      "camera": {\n        "position": [0.05, 0.0, 0.05],\n        "orientation": [0.0, 0.0, 0.0, 1.0],\n        "resolution": [640, 480],\n        "fov": 60.0,\n        "near_plane": 0.1,\n        "far_plane": 100.0\n      },\n      "lidar": {\n        "position": [0.1, 0.0, 0.8],\n        "orientation": [0.0, 0.0, 0.0, 1.0],\n        "rotation_frequency": 10.0,\n        "channels": 16,\n        "points_per_channel": 1000,\n        "range": 25.0\n      }\n    },\n    "ros_bridge_settings": {\n      "enabled": true,\n      "namespace": "autonomous_humanoid",\n      "qos_profiles": {\n        "sensor_data": {\n          "reliability": "reliable",\n          "durability": "volatile",\n          "depth": 10\n        },\n        "control_commands": {\n          "reliability": "best_effort",\n          "durability": "volatile",\n          "depth": 1\n        }\n      },\n      "topics": {\n        "joint_states": "/autonomous_humanoid/joint_states",\n        "imu_data": "/autonomous_humanoid/imu/data_raw",\n        "camera_image": "/autonomous_humanoid/camera/image_rect_color",\n        "lidar_scan": "/autonomous_humanoid/lidar/scan",\n        "cmd_vel": "/autonomous_humanoid/cmd_vel",\n        "joint_commands": "/autonomous_humanoid/joint_commands"\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-rclpy-in-humanoid-robotics",children:"Best Practices for rclpy in Humanoid Robotics"}),"\n",(0,i.jsx)(n.p,{children:"When developing humanoid robotics applications with rclpy, consider the following best practices:"}),"\n",(0,i.jsx)(n.h3,{id:"1-performance-optimization",children:"1. Performance Optimization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS profiles for different types of data"}),"\n",(0,i.jsx)(n.li,{children:"Implement message filtering and decimation for high-frequency data"}),"\n",(0,i.jsx)(n.li,{children:"Use threading carefully to avoid blocking the main ROS loop"}),"\n",(0,i.jsx)(n.li,{children:"Consider using C++ for computationally intensive real-time tasks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-error-handling-and-safety",children:"2. Error Handling and Safety"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement proper exception handling for all ROS operations"}),"\n",(0,i.jsx)(n.li,{children:"Use timeouts for service calls and action clients"}),"\n",(0,i.jsx)(n.li,{children:"Implement safety checks before executing commands"}),"\n",(0,i.jsx)(n.li,{children:"Monitor system resources and implement graceful degradation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-memory-management",children:"3. Memory Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use message buffers appropriately to avoid memory leaks"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper cleanup in node destruction"}),"\n",(0,i.jsx)(n.li,{children:"Monitor memory usage in long-running nodes"}),"\n",(0,i.jsx)(n.li,{children:"Use generators for processing large datasets"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-parameter-management",children:"4. Parameter Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use ROS 2 parameters for runtime configuration"}),"\n",(0,i.jsx)(n.li,{children:"Implement parameter validation callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Provide reasonable default values"}),"\n",(0,i.jsx)(n.li,{children:"Document parameter purposes and constraints"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-testing-and-debugging",children:"5. Testing and Debugging"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement diagnostic publishers for system health"}),"\n",(0,i.jsx)(n.li,{children:"Use ROS 2 logging appropriately (debug, info, warn, error)"}),"\n",(0,i.jsx)(n.li,{children:"Implement test nodes for individual components"}),"\n",(0,i.jsx)(n.li,{children:"Use rqt and other ROS 2 tools for debugging"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"rclpy provides a powerful bridge between Python's rich ecosystem of scientific computing and AI libraries and the ROS 2 framework. For humanoid robotics applications, this enables the integration of sophisticated algorithms while maintaining the real-time capabilities needed for robot control. The examples provided demonstrate advanced patterns for publishers, subscribers, services, and parameter management that are essential for developing robust humanoid robot systems."}),"\n",(0,i.jsx)(n.p,{children:"The integration with simulation environments like NVIDIA Isaac Sim allows for safe testing and validation of complex humanoid behaviors before deployment on physical hardware. Proper use of QoS profiles, parameter management, and error handling enables the development of reliable, high-performance humanoid robot systems that can operate safely in real-world environments."}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-nvidia-isaac-sim",children:"Integration with NVIDIA Isaac Sim"}),"\n",(0,i.jsx)(n.p,{children:"The following configuration shows how to set up rclpy nodes to work with NVIDIA Isaac Sim for humanoid robotics simulation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Isaac Sim integration configuration\nisaac_sim_config = {\n    "ros_bridge": {\n        "enabled": True,\n        "namespace": "autonomous_humanoid",\n        "qos_settings": {\n            "sensor_data": {\n                "reliability": "reliable",\n                "durability": "volatile",\n                "depth": 10\n            },\n            "control_commands": {\n                "reliability": "best_effort",\n                "durability": "volatile",\n                "depth": 1\n            }\n        }\n    },\n    "robot_interface": {\n        "joint_state_topic": "/autonomous_humanoid/joint_states",\n        "cmd_vel_topic": "/autonomous_humanoid/cmd_vel",\n        "imu_topic": "/autonomous_humanoid/imu/data",\n        "camera_topic": "/autonomous_humanoid/camera/image_raw",\n        "lidar_topic": "/autonomous_humanoid/lidar/scan"\n    },\n    "simulation_parameters": {\n        "physics_update_rate": 500,  # Hz\n        "rendering_update_rate": 60,  # Hz\n        "gravity": [0.0, 0.0, -9.81],\n        "time_scale": 1.0\n    },\n    "robot_config": {\n        "urdf_path": "/assets/robots/humanoid.urdf",\n        "initial_position": [0.0, 0.0, 1.0],\n        "initial_orientation": [0.0, 0.0, 0.0, 1.0]\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-rclpy-in-humanoid-robotics-1",children:"Best Practices for rclpy in Humanoid Robotics"}),"\n",(0,i.jsx)(n.p,{children:"When developing humanoid robotics applications with rclpy, consider the following best practices:"}),"\n",(0,i.jsx)(n.h3,{id:"1-performance-optimization-1",children:"1. Performance Optimization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use appropriate QoS profiles for different types of data"}),"\n",(0,i.jsx)(n.li,{children:"Implement message filtering and decimation for high-frequency data"}),"\n",(0,i.jsx)(n.li,{children:"Use threading carefully to avoid blocking the main ROS loop"}),"\n",(0,i.jsx)(n.li,{children:"Consider using C++ for computationally intensive real-time tasks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-error-handling-and-safety-1",children:"2. Error Handling and Safety"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement proper exception handling for all ROS operations"}),"\n",(0,i.jsx)(n.li,{children:"Use timeouts for service calls and action clients"}),"\n",(0,i.jsx)(n.li,{children:"Implement safety checks before executing commands"}),"\n",(0,i.jsx)(n.li,{children:"Monitor system resources and implement graceful degradation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-memory-management-1",children:"3. Memory Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use message buffers appropriately to avoid memory leaks"}),"\n",(0,i.jsx)(n.li,{children:"Implement proper cleanup in node destruction"}),"\n",(0,i.jsx)(n.li,{children:"Monitor memory usage in long-running nodes"}),"\n",(0,i.jsx)(n.li,{children:"Use generators for processing large datasets"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-parameter-management-1",children:"4. Parameter Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use ROS 2 parameters for runtime configuration"}),"\n",(0,i.jsx)(n.li,{children:"Implement parameter validation callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Provide reasonable default values"}),"\n",(0,i.jsx)(n.li,{children:"Document parameter purposes and constraints"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-testing-and-debugging-1",children:"5. Testing and Debugging"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement diagnostic publishers for system health"}),"\n",(0,i.jsx)(n.li,{children:"Use ROS 2 logging appropriately (debug, info, warn, error)"}),"\n",(0,i.jsx)(n.li,{children:"Implement test nodes for individual components"}),"\n",(0,i.jsx)(n.li,{children:"Use rqt and other ROS 2 tools for debugging"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary-1",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"rclpy provides a powerful bridge between Python's rich ecosystem of scientific computing and AI libraries and the ROS 2 framework. For humanoid robotics applications, this enables the integration of sophisticated algorithms while maintaining the real-time capabilities needed for robot control. The examples provided demonstrate advanced patterns for publishers, subscribers, services, and parameter management that are essential for developing robust humanoid robot systems."}),"\n",(0,i.jsx)(n.p,{children:"The integration with simulation environments like NVIDIA Isaac Sim allows for safe testing and validation of complex humanoid behaviors before deployment on physical hardware. Proper use of QoS profiles, parameter management, and error handling enables the development of reliable, high-performance humanoid robot systems that can operate safely in real-world environments."})]})}function _(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);