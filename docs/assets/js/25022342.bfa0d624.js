"use strict";(globalThis.webpackChunkclassic=globalThis.webpackChunkclassic||[]).push([[433],{7499(e,n,t){t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>_});const a=JSON.parse('{"id":"module-3/nav2-path-planning","title":"Nav2 Path Planning","description":"Navigation and Path Planning","source":"@site/docs/module-3/nav2-path-planning.md","sourceDirName":"module-3","slug":"/module-3/nav2-path-planning","permalink":"/ebsite/docs/docs/module-3/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/sherazi-412002/ai-native-sdd-books/tree/main/docs/module-3/nav2-path-planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"curriculumSidebar","previous":{"title":"Isaac ROS VSLAM","permalink":"/ebsite/docs/docs/module-3/isaac-ros-vslam"},"next":{"title":"Module 4: Vision-Language-Action (VLA)","permalink":"/ebsite/docs/docs/category/module-4-vision-language-action-vla"}}');var o=t(4848),s=t(8453);const l={sidebar_position:3},r="Nav2 Path Planning",i={},_=[{value:"Navigation and Path Planning",id:"navigation-and-path-planning",level:2},{value:"Navigation Stack Overview",id:"navigation-stack-overview",level:2},{value:"Costmaps",id:"costmaps",level:2},{value:"Global Path Planning",id:"global-path-planning",level:2},{value:"Local Path Planning",id:"local-path-planning",level:2},{value:"Controller Plugins",id:"controller-plugins",level:2},{value:"Humanoid-Specific Navigation",id:"humanoid-specific-navigation",level:2},{value:"Isaac Sim Setup Parameters",id:"isaac-sim-setup-parameters",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"nav2-path-planning",children:"Nav2 Path Planning"})}),"\n",(0,o.jsx)(n.h2,{id:"navigation-and-path-planning",children:"Navigation and Path Planning"}),"\n",(0,o.jsx)(n.p,{children:"This chapter covers navigation and path planning using Nav2 (Navigation 2) for humanoid robots. Nav2 is the state-of-the-art navigation stack for ROS 2, providing robust and flexible path planning capabilities for mobile robots. For humanoid robots, navigation presents unique challenges due to their bipedal locomotion, balance constraints, and complex kinematics."}),"\n",(0,o.jsx)(n.p,{children:"The Nav2 stack consists of several key components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Global Planner"}),": Generates a high-level path from start to goal"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Local Planner"}),": Executes the path while avoiding obstacles in real-time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Controller"}),": Converts planned paths into robot motion commands"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Costmaps"}),": Represent the environment with obstacles and navigation constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Recovery Behaviors"}),": Handle navigation failures and recover from difficult situations"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"navigation-stack-overview",children:"Navigation Stack Overview"}),"\n",(0,o.jsx)(n.p,{children:"The Nav2 architecture is built around a flexible plugin system that allows users to customize each component based on their specific robot and application requirements. Here's a comprehensive implementation of Nav2 for humanoid robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom nav2_msgs.action import NavigateToPose\nfrom nav_msgs.msg import Path, OccupancyGrid\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom sensor_msgs.msg import LaserScan, PointCloud2\nfrom geometry_msgs.msg import Twist\nfrom tf2_ros import TransformListener, Buffer\nimport tf2_geometry_msgs\nimport numpy as np\nfrom typing import List, Tuple, Optional\nimport math\nfrom enum import Enum\nimport threading\nimport time\n\nclass NavigationState(Enum):\n    """Navigation state enumeration"""\n    IDLE = 0\n    PLANNING = 1\n    EXECUTING = 2\n    RECOVERING = 3\n    CANCELLED = 4\n    COMPLETED = 5\n    FAILED = 6\n\nclass Nav2PathPlanner(Node):\n    """\n    Comprehensive Nav2 path planning implementation for humanoid robots\n    """\n\n    def __init__(self):\n        super().__init__(\'nav2_path_planner\')\n\n        # Declare parameters\n        self.declare_parameter(\'global_frame\', \'map\')\n        self.declare_parameter(\'robot_base_frame\', \'base_link\')\n        self.declare_parameter(\'planner_frequency\', 5.0)\n        self.declare_parameter(\'controller_frequency\', 20.0)\n        self.declare_parameter(\'max_vel_x\', 0.5)\n        self.declare_parameter(\'min_vel_x\', 0.1)\n        self.declare_parameter(\'max_vel_theta\', 1.0)\n        self.declare_parameter(\'min_in_place_vel_theta\', 0.4)\n        self.declare_parameter(\'acc_lim_x\', 2.5)\n        self.declare_parameter(\'acc_lim_theta\', 3.2)\n        self.declare_parameter(\'xy_goal_tolerance\', 0.25)\n        self.declare_parameter(\'yaw_goal_tolerance\', 0.25)\n\n        # Get parameters\n        self.global_frame = self.get_parameter(\'global_frame\').value\n        self.robot_base_frame = self.get_parameter(\'robot_base_frame\').value\n        self.planner_frequency = self.get_parameter(\'planner_frequency\').value\n        self.controller_frequency = self.get_parameter(\'controller_frequency\').value\n        self.max_vel_x = self.get_parameter(\'max_vel_x\').value\n        self.min_vel_x = self.get_parameter(\'min_vel_x\').value\n        self.max_vel_theta = self.get_parameter(\'max_vel_theta\').value\n        self.min_in_place_vel_theta = self.get_parameter(\'min_in_place_vel_theta\').value\n        self.acc_lim_x = self.get_parameter(\'acc_lim_x\').value\n        self.acc_lim_theta = self.get_parameter(\'acc_lim_theta\').value\n        self.xy_goal_tolerance = self.get_parameter(\'xy_goal_tolerance\').value\n        self.yaw_goal_tolerance = self.get_parameter(\'yaw_goal_tolerance\').value\n\n        # Navigation state\n        self.navigation_state = NavigationState.IDLE\n        self.current_pose = None\n        self.goal_pose = None\n        self.global_path = None\n        self.local_plan = None\n\n        # TF setup\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Publishers\n        self.global_path_pub = self.create_publisher(Path, \'global_plan\', 10)\n        self.local_path_pub = self.create_publisher(Path, \'local_plan\', 10)\n        self.velocity_pub = self.create_publisher(Twist, \'cmd_vel\', 10)\n        self.current_pose_pub = self.create_publisher(PoseStamped, \'current_pose\', 10)\n\n        # Subscribers\n        self.costmap_sub = self.create_subscription(\n            OccupancyGrid, \'global_costmap/costmap\', self.costmap_callback, 10)\n        self.scan_sub = self.create_subscription(\n            LaserScan, \'scan\', self.scan_callback, 10)\n\n        # Timers\n        self.update_timer = self.create_timer(1.0/self.planner_frequency, self.update_callback)\n\n        # Threading\n        self.nav_lock = threading.RLock()\n\n        self.get_logger().info(\'Nav2 Path Planner initialized\')\n\n    def update_callback(self):\n        """Main navigation update callback"""\n        # Update robot pose from TF\n        self.update_robot_pose()\n\n        # Execute navigation logic based on state\n        with self.nav_lock:\n            if self.navigation_state == NavigationState.PLANNING:\n                self.plan_global_path()\n            elif self.navigation_state == NavigationState.EXECUTING:\n                self.execute_local_plan()\n\n    def update_robot_pose(self):\n        """Update current robot pose from TF"""\n        try:\n            transform = self.tf_buffer.lookup_transform(\n                self.global_frame,\n                self.robot_base_frame,\n                rclpy.time.Time())\n\n            pose = PoseStamped()\n            pose.header.stamp = self.get_clock().now().to_msg()\n            pose.header.frame_id = self.global_frame\n            pose.pose.position.x = transform.transform.translation.x\n            pose.pose.position.y = transform.transform.translation.y\n            pose.pose.position.z = transform.transform.translation.z\n            pose.pose.orientation = transform.transform.rotation\n\n            self.current_pose = pose\n            self.current_pose_pub.publish(pose)\n\n        except Exception as e:\n            self.get_logger().warn(f\'Could not get transform: {str(e)}\')\n\n    def set_goal(self, goal_pose: PoseStamped):\n        """Set navigation goal"""\n        with self.nav_lock:\n            self.goal_pose = goal_pose\n            self.navigation_state = NavigationState.PLANNING\n\n    def plan_global_path(self):\n        """Plan global path using A* or Dijkstra algorithm"""\n        if not self.current_pose or not self.goal_pose:\n            return\n\n        # In a real implementation, this would call the global planner plugin\n        # For this example, we\'ll create a simple path\n        path = self.compute_simple_path(\n            self.current_pose.pose,\n            self.goal_pose.pose\n        )\n\n        if path:\n            self.global_path = path\n            self.publish_global_path(path)\n            self.navigation_state = NavigationState.EXECUTING\n        else:\n            self.navigation_state = NavigationState.FAILED\n\n    def compute_simple_path(self, start_pose, goal_pose) -> Optional[Path]:\n        """Compute a simple path (in practice, this would be a more sophisticated planner)"""\n        path_msg = Path()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = self.global_frame\n\n        # Simple straight-line path with intermediate waypoints\n        start_x = start_pose.position.x\n        start_y = start_pose.position.y\n        goal_x = goal_pose.position.x\n        goal_y = goal_pose.position.y\n\n        # Calculate distance and intermediate points\n        dist = math.sqrt((goal_x - start_x)**2 + (goal_y - start_y)**2)\n        num_points = max(2, int(dist / 0.5))  # 0.5m between waypoints\n\n        for i in range(num_points):\n            t = i / (num_points - 1) if num_points > 1 else 0\n            x = start_x + t * (goal_x - start_x)\n            y = start_y + t * (goal_y - start_y)\n\n            pose_stamped = PoseStamped()\n            pose_stamped.header.frame_id = self.global_frame\n            pose_stamped.pose.position.x = x\n            pose_stamped.pose.position.y = y\n            pose_stamped.pose.position.z = 0.0\n\n            # Calculate orientation to face the next point\n            if i < num_points - 1:\n                next_x = start_x + (i+1) / (num_points - 1) * (goal_x - start_x)\n                next_y = start_y + (i+1) / (num_points - 1) * (goal_y - start_y)\n                yaw = math.atan2(next_y - y, next_x - x)\n\n                # Convert yaw to quaternion\n                pose_stamped.pose.orientation.z = math.sin(yaw / 2.0)\n                pose_stamped.pose.orientation.w = math.cos(yaw / 2.0)\n            else:\n                # Use goal orientation\n                pose_stamped.pose.orientation = goal_pose.orientation\n\n            path_msg.poses.append(pose_stamped)\n\n        return path_msg\n\n    def execute_local_plan(self):\n        """Execute local path following with obstacle avoidance"""\n        if not self.global_path or not self.current_pose:\n            return\n\n        # Get next local path segment\n        local_path = self.get_local_path_segment()\n        if local_path:\n            self.local_plan = local_path\n            self.publish_local_path(local_path)\n\n            # Compute velocity command\n            cmd_vel = self.compute_velocity_command(local_path)\n            if cmd_vel:\n                self.velocity_pub.publish(cmd_vel)\n\n                # Check if goal is reached\n                if self.is_goal_reached():\n                    self.navigation_state = NavigationState.COMPLETED\n\n    def get_local_path_segment(self) -> Optional[Path]:\n        """Get the next segment of the global path to follow"""\n        if not self.global_path or not self.current_pose:\n            return None\n\n        # Find the closest point on the path\n        closest_idx = self.find_closest_point_on_path()\n        if closest_idx is None:\n            return None\n\n        # Create local path from current position to look-ahead point\n        local_path = Path()\n        local_path.header = self.global_path.header\n\n        # Include points from closest point up to look-ahead distance\n        look_ahead_dist = 2.0  # meters\n        start_idx = closest_idx\n        end_idx = start_idx\n\n        current_dist = 0.0\n        for i in range(start_idx, len(self.global_path.poses)):\n            if i == start_idx:\n                continue\n\n            prev_pose = self.global_path.poses[i-1].pose.position\n            curr_pose = self.global_path.poses[i].pose.position\n            segment_dist = math.sqrt(\n                (curr_pose.x - prev_pose.x)**2 + (curr_pose.y - prev_pose.y)**2\n            )\n\n            if current_dist + segment_dist > look_ahead_dist:\n                break\n\n            current_dist += segment_dist\n            local_path.poses.append(self.global_path.poses[i])\n            end_idx = i\n\n        return local_path if len(local_path.poses) > 0 else None\n\n    def find_closest_point_on_path(self) -> Optional[int]:\n        """Find the closest point on the global path to the current robot position"""\n        if not self.global_path or not self.current_pose:\n            return None\n\n        robot_x = self.current_pose.pose.position.x\n        robot_y = self.current_pose.pose.position.y\n\n        min_dist = float(\'inf\')\n        closest_idx = 0\n\n        for i, pose in enumerate(self.global_path.poses):\n            dist = math.sqrt(\n                (pose.pose.position.x - robot_x)**2 +\n                (pose.pose.position.y - robot_y)**2\n            )\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        return closest_idx if min_dist < float(\'inf\') else None\n\n    def compute_velocity_command(self, local_path: Path) -> Optional[Twist]:\n        """Compute velocity command based on local path"""\n        if not local_path.poses or not self.current_pose:\n            return None\n\n        # Get the next point on the path\n        next_pose = local_path.poses[0].pose\n\n        # Calculate desired direction and distance\n        robot_x = self.current_pose.pose.position.x\n        robot_y = self.current_pose.pose.position.y\n        robot_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.orientation)\n\n        dx = next_pose.position.x - robot_x\n        dy = next_pose.position.y - robot_y\n        distance = math.sqrt(dx**2 + dy**2)\n\n        # Calculate angle to the next point\n        angle_to_goal = math.atan2(dy, dx)\n        angle_diff = angle_to_goal - robot_yaw\n\n        # Normalize angle\n        while angle_diff > math.pi:\n            angle_diff -= 2 * math.pi\n        while angle_diff < -math.pi:\n            angle_diff += 2 * math.pi\n\n        # Create velocity command\n        cmd_vel = Twist()\n\n        # If angle is too large, rotate in place first\n        if abs(angle_diff) > math.pi / 4:  # 45 degrees\n            cmd_vel.angular.z = max(-self.max_vel_theta, min(self.max_vel_theta,\n                self.max_vel_theta * angle_diff / abs(angle_diff)))\n        else:\n            # Move forward while adjusting orientation\n            cmd_vel.linear.x = max(self.min_vel_x, min(self.max_vel_x,\n                self.max_vel_x * min(1.0, distance)))\n            cmd_vel.angular.z = max(-self.max_vel_theta, min(self.max_vel_theta,\n                self.max_vel_theta * angle_diff))\n\n        return cmd_vel\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def is_goal_reached(self) -> bool:\n        """Check if the goal has been reached"""\n        if not self.goal_pose or not self.current_pose:\n            return False\n\n        # Check position tolerance\n        pos_diff = math.sqrt(\n            (self.goal_pose.pose.position.x - self.current_pose.pose.position.x)**2 +\n            (self.goal_pose.pose.position.y - self.current_pose.pose.position.y)**2\n        )\n\n        # Check orientation tolerance\n        goal_yaw = self.get_yaw_from_quaternion(self.goal_pose.pose.orientation)\n        current_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.orientation)\n        angle_diff = abs(goal_yaw - current_yaw)\n\n        return pos_diff <= self.xy_goal_tolerance and angle_diff <= self.yaw_goal_tolerance\n\n    def costmap_callback(self, msg: OccupancyGrid):\n        """Handle costmap updates"""\n        # Process costmap data for obstacle detection and path planning\n        pass\n\n    def scan_callback(self, msg: LaserScan):\n        """Handle laser scan data for local obstacle detection"""\n        # Process laser scan for local path adjustment and obstacle avoidance\n        pass\n\n    def publish_global_path(self, path: Path):\n        """Publish global path for visualization"""\n        self.global_path_pub.publish(path)\n\n    def publish_local_path(self, path: Path):\n        """Publish local path for visualization"""\n        self.local_path_pub.publish(path)\n\nclass HumanoidPathPlanner(Nav2PathPlanner):\n    """\n    Humanoid-specific path planning that accounts for bipedal locomotion constraints\n    """\n\n    def __init__(self):\n        super().__init__()\n\n        # Humanoid-specific parameters\n        self.declare_parameter(\'step_height\', 0.05)  # Height of each step\n        self.declare_parameter(\'step_length\', 0.3)   # Length of each step\n        self.declare_parameter(\'step_duration\', 0.5) # Duration of each step\n        self.declare_parameter(\'max_step_up\', 0.1)   # Maximum step up height\n        self.declare_parameter(\'max_step_down\', 0.1) # Maximum step down height\n        self.declare_parameter(\'max_lean_angle\', 0.2) # Maximum lean angle (radians)\n\n        self.step_height = self.get_parameter(\'step_height\').value\n        self.step_length = self.get_parameter(\'step_length\').value\n        self.step_duration = self.get_parameter(\'step_duration\').value\n        self.max_step_up = self.get_parameter(\'max_step_up\').value\n        self.max_step_down = self.get_parameter(\'max_step_down\').value\n        self.max_lean_angle = self.get_parameter(\'max_lean_angle\').value\n\n        # Initialize humanoid-specific components\n        self.balance_controller = BalanceController()\n        self.step_planner = StepPlanner()\n\n    def compute_velocity_command(self, local_path: Path) -> Optional[Twist]:\n        """Humanoid-specific velocity command computation"""\n        if not local_path.poses or not self.current_pose:\n            return None\n\n        # Use step planner to generate footstep plan\n        footstep_plan = self.step_planner.plan_footsteps(\n            self.current_pose.pose, local_path, self.step_length\n        )\n\n        # Generate balance-aware velocity command\n        cmd_vel = Twist()\n\n        # Calculate desired forward velocity based on footsteps\n        if footstep_plan and len(footstep_plan) > 0:\n            # Get the next step in the plan\n            next_step = footstep_plan[0]\n\n            # Calculate distance to next step\n            robot_x = self.current_pose.pose.position.x\n            robot_y = self.current_pose.pose.position.y\n            step_x = next_step.position.x\n            step_y = next_step.position.y\n            distance_to_step = math.sqrt((step_x - robot_x)**2 + (step_y - robot_y)**2)\n\n            # Calculate velocity to reach next step\n            desired_vel = distance_to_step / (self.step_duration / 2)  # Half step duration to reach midpoint\n            cmd_vel.linear.x = min(self.max_vel_x, max(self.min_vel_x, desired_vel))\n\n            # Calculate angular velocity to face next step\n            robot_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.orientation)\n            desired_yaw = math.atan2(step_y - robot_y, step_x - robot_x)\n            angle_diff = desired_yaw - robot_yaw\n\n            # Normalize angle\n            while angle_diff > math.pi:\n                angle_diff -= 2 * math.pi\n            while angle_diff < -math.pi:\n                angle_diff += 2 * math.pi\n\n            cmd_vel.angular.z = max(-self.max_vel_theta, min(self.max_vel_theta,\n                self.max_vel_theta * angle_diff))\n\n        # Apply balance constraints\n        cmd_vel = self.balance_controller.apply_balance_constraints(cmd_vel)\n\n        return cmd_vel\n\n    def is_goal_reached(self) -> bool:\n        """Humanoid-specific goal reached check"""\n        if not self.goal_pose or not self.current_pose:\n            return False\n\n        # Check position tolerance\n        pos_diff = math.sqrt(\n            (self.goal_pose.pose.position.x - self.current_pose.pose.position.x)**2 +\n            (self.goal_pose.pose.position.y - self.current_pose.pose.position.y)**2\n        )\n\n        # Check orientation tolerance\n        goal_yaw = self.get_yaw_from_quaternion(self.goal_pose.pose.orientation)\n        current_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.orientation)\n        angle_diff = abs(goal_yaw - current_yaw)\n\n        # Additional check for humanoid-specific constraints\n        # Consider goal reached if within step length of goal\n        return pos_diff <= max(self.xy_goal_tolerance, self.step_length) and angle_diff <= self.yaw_goal_tolerance\n\nclass BalanceController:\n    """\n    Balance controller for humanoid robots during navigation\n    """\n\n    def __init__(self):\n        self.max_lean_angle = 0.2  # radians\n        self.com_height = 0.8      # Center of mass height (meters)\n        self.zmp_margin = 0.05     # Zero Moment Point safety margin\n\n    def apply_balance_constraints(self, cmd_vel: Twist) -> Twist:\n        """Apply balance constraints to velocity command"""\n        # Limit velocities based on balance constraints\n        # This is a simplified model - real implementations would use ZMP or LIPM\n        max_stable_linear_vel = self.calculate_max_stable_linear_velocity()\n        max_stable_angular_vel = self.calculate_max_stable_angular_velocity()\n\n        cmd_vel.linear.x = max(-max_stable_linear_vel,\n                              min(max_stable_linear_vel, cmd_vel.linear.x))\n        cmd_vel.angular.z = max(-max_stable_angular_vel,\n                               min(max_stable_angular_vel, cmd_vel.angular.z))\n\n        return cmd_vel\n\n    def calculate_max_stable_linear_velocity(self) -> float:\n        """Calculate maximum stable linear velocity based on balance"""\n        # Simplified calculation based on inverted pendulum model\n        # v_max = sqrt(g * h / L) where g is gravity, h is CoM height, L is step length\n        g = 9.81  # gravity\n        # This is a simplified model - real implementation would be more complex\n        return 0.5  # Return a safe default value\n\n    def calculate_max_stable_angular_velocity(self) -> float:\n        """Calculate maximum stable angular velocity based on balance"""\n        # Simplified calculation\n        return 0.5  # Return a safe default value\n\nclass StepPlanner:\n    """\n    Footstep planner for humanoid robots\n    """\n\n    def __init__(self):\n        self.step_length = 0.3  # meters\n        self.step_width = 0.2   # meters (distance between feet)\n        self.max_step_up = 0.1  # maximum step up height\n        self.max_step_down = 0.1  # maximum step down height\n\n    def plan_footsteps(self, current_pose, path: Path, step_length: float) -> List[PoseStamped]:\n        """Plan footsteps along the path"""\n        footsteps = []\n\n        if not path.poses:\n            return footsteps\n\n        # Start from current position\n        current_x = current_pose.position.x\n        current_y = current_pose.position.y\n        current_yaw = self.get_yaw_from_quaternion(current_pose.orientation)\n\n        # Generate footsteps along the path\n        for i, pose_stamped in enumerate(path.poses):\n            target_x = pose_stamped.pose.position.x\n            target_y = pose_stamped.pose.position.y\n\n            # Calculate distance to target\n            dist = math.sqrt((target_x - current_x)**2 + (target_y - current_y)**2)\n\n            # Generate intermediate footsteps\n            num_steps = int(dist / step_length)\n            for j in range(num_steps):\n                step_x = current_x + (j + 1) * (target_x - current_x) / num_steps\n                step_y = current_y + (j + 1) * (target_y - current_y) / num_steps\n\n                # Alternate between left and right foot\n                step_offset = self.step_width / 2 if j % 2 == 0 else -self.step_width / 2\n                step_x += step_offset * math.sin(current_yaw)\n                step_y += step_offset * math.cos(current_yaw)\n\n                step_pose = PoseStamped()\n                step_pose.header = path.header\n                step_pose.pose.position.x = step_x\n                step_pose.pose.position.y = step_y\n                step_pose.pose.position.z = 0.0\n                step_pose.pose.orientation = pose_stamped.pose.orientation\n\n                footsteps.append(step_pose)\n\n        return footsteps\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    path_planner = HumanoidPathPlanner()\n\n    try:\n        rclpy.spin(path_planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        path_planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"costmaps",children:"Costmaps"}),"\n",(0,o.jsx)(n.p,{children:"Costmaps are a fundamental component of the Nav2 navigation stack that represent the environment with obstacles, free space, and navigation constraints. For humanoid robots, costmaps need to account for the robot's unique shape, size, and locomotion constraints."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Tuple\nimport cv2\nfrom nav_msgs.msg import OccupancyGrid\nfrom geometry_msgs.msg import Point\nfrom sensor_msgs.msg import LaserScan\nimport threading\n\nclass Costmap2D:\n    """\n    2D Costmap implementation for humanoid robot navigation\n    """\n\n    def __init__(self,\n                 resolution: float = 0.05,  # meters per cell\n                 width: int = 200,          # cells\n                 height: int = 200,         # cells\n                 origin_x: float = -5.0,    # meters\n                 origin_y: float = -5.0):   # meters\n        self.resolution = resolution\n        self.width = width\n        self.height = height\n        self.origin_x = origin_x\n        self.origin_y = origin_y\n\n        # Initialize costmap\n        self.costmap = np.zeros((height, width), dtype=np.int8)\n        self.update_lock = threading.RLock()\n\n        # Cost values\n        self.COST_UNKNOWN = -1\n        self.COST_FREE = 0\n        self.COST_INSCRIBED = 99\n        self.COST_LETHAL = 100\n\n        # Robot footprint (for humanoid: approximate as a rectangle)\n        self.robot_footprint = self.create_robot_footprint()\n\n    def create_robot_footprint(self) -> List[Tuple[float, float]]:\n        """\n        Create robot footprint for costmap operations\n        For a humanoid robot, this might be a rectangle representing the base\n        """\n        # Approximate humanoid base as 0.5m x 0.4m rectangle\n        half_width = 0.25  # meters\n        half_length = 0.2  # meters\n\n        footprint = [\n            (-half_length, -half_width),\n            (-half_length, half_width),\n            (half_length, half_width),\n            (half_length, -half_width)\n        ]\n\n        return footprint\n\n    def world_to_map(self, x_world: float, y_world: float) -> Tuple[int, int]:\n        """Convert world coordinates to map coordinates"""\n        x_map = int((x_world - self.origin_x) / self.resolution)\n        y_map = int((y_world - self.origin_y) / self.resolution)\n\n        return x_map, y_map\n\n    def map_to_world(self, x_map: int, y_map: int) -> Tuple[float, float]:\n        """Convert map coordinates to world coordinates"""\n        x_world = x_map * self.resolution + self.origin_x\n        y_world = y_map * self.resolution + self.origin_y\n\n        return x_world, y_world\n\n    def is_valid_cell(self, x: int, y: int) -> bool:\n        """Check if map coordinates are valid"""\n        return 0 <= x < self.width and 0 <= y < self.height\n\n    def ray_trace(self, x0: float, y0: float, x1: float, y1: float,\n                  max_range: float = 10.0) -> List[Tuple[int, int]]:\n        """Ray trace between two points in the costmap"""\n        x0_map, y0_map = self.world_to_map(x0, y0)\n        x1_map, y1_map = self.world_to_map(x1, y1)\n\n        # Bresenham\'s line algorithm\n        points = []\n        dx = abs(x1_map - x0_map)\n        dy = abs(y1_map - y0_map)\n        x_step = 1 if x0_map < x1_map else -1\n        y_step = 1 if y0_map < y1_map else -1\n\n        error = dx - dy\n        x, y = x0_map, y0_map\n\n        while True:\n            if self.is_valid_cell(x, y):\n                points.append((x, y))\n\n            if x == x1_map and y == y1_map:\n                break\n\n            error2 = 2 * error\n            if error2 > -dy:\n                error -= dy\n                x += x_step\n            if error2 < dx:\n                error += dx\n                y += y_step\n\n        return points\n\n    def update_with_laser_scan(self, scan: LaserScan, robot_pose):\n        """Update costmap with laser scan data"""\n        with self.update_lock:\n            # Convert scan points to world coordinates\n            angle_min = scan.angle_min\n            angle_increment = scan.angle_increment\n\n            robot_x = robot_pose.position.x\n            robot_y = robot_pose.position.y\n            robot_yaw = self.get_yaw_from_quaternion(robot_pose.orientation)\n\n            for i, range_val in enumerate(scan.ranges):\n                if range_val < scan.range_min or range_val > scan.range_max:\n                    continue\n\n                # Calculate angle of this range measurement\n                angle = angle_min + i * angle_increment + robot_yaw\n\n                # Calculate world coordinates of obstacle\n                obs_x = robot_x + range_val * math.cos(angle)\n                obs_y = robot_y + range_val * math.sin(angle)\n\n                # Get map coordinates\n                obs_x_map, obs_y_map = self.world_to_map(obs_x, obs_y)\n\n                if self.is_valid_cell(obs_x_map, obs_y_map):\n                    # Set obstacle cost\n                    self.costmap[obs_y_map, obs_x_map] = self.COST_LETHAL\n\n                    # Ray trace to clear free space\n                    points = self.ray_trace(robot_x, robot_y, obs_x, obs_y)\n                    for x, y in points[:-1]:  # Don\'t clear the obstacle point\n                        if self.is_valid_cell(x, y):\n                            if self.costmap[y, x] < self.COST_INSCRIBED:\n                                self.costmap[y, x] = self.COST_FREE\n\n    def get_cost(self, x_world: float, y_world: float) -> int:\n        """Get cost at world coordinates"""\n        x_map, y_map = self.world_to_map(x_world, y_world)\n\n        if self.is_valid_cell(x_map, y_map):\n            return self.costmap[y_map, x_map]\n        else:\n            return self.COST_LETHAL  # Outside map is lethal\n\n    def is_free(self, x_world: float, y_world: float) -> bool:\n        """Check if a point is free for navigation"""\n        cost = self.get_cost(x_world, y_world)\n        return cost < self.COST_INSCRIBED\n\n    def is_occupied(self, x_world: float, y_world: float) -> bool:\n        """Check if a point is occupied"""\n        cost = self.get_cost(x_world, y_world)\n        return cost >= self.COST_INSCRIBED\n\n    def get_neighbors(self, x: int, y: int) -> List[Tuple[int, int]]:\n        """Get valid neighboring cells"""\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip current cell\n                nx, ny = x + dx, y + dy\n                if self.is_valid_cell(nx, ny):\n                    neighbors.append((nx, ny))\n        return neighbors\n\n    def inflate_obstacles(self, inflation_radius: float):\n        """Inflate obstacles by a given radius"""\n        inflation_cells = int(inflation_radius / self.resolution)\n\n        # Create a copy of the original costmap\n        original_costmap = self.costmap.copy()\n\n        for i in range(self.height):\n            for j in range(self.width):\n                if original_costmap[i, j] >= self.COST_INSCRIBED:\n                    # Inflate this obstacle\n                    for di in range(-inflation_cells, inflation_cells + 1):\n                        for dj in range(-inflation_cells, inflation_cells + 1):\n                            ni, nj = i + di, j + dj\n                            if self.is_valid_cell(nj, ni):  # Note: x, y order\n                                dist = math.sqrt(di**2 + dj**2) * self.resolution\n                                if dist <= inflation_radius:\n                                    current_cost = self.costmap[ni, nj]\n                                    new_cost = min(self.COST_LETHAL,\n                                                 int(100 * (1 - dist / inflation_radius)))\n                                    self.costmap[ni, nj] = max(current_cost, new_cost)\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\nclass LayeredCostmap:\n    """\n    Layered costmap that combines multiple sources of information\n    """\n\n    def __init__(self, global_frame: str = \'map\'):\n        self.global_frame = global_frame\n        self.layers = []\n        self.master_costmap = None\n        self.resolution = 0.05\n        self.width = 200\n        self.height = 200\n        self.origin_x = -5.0\n        self.origin_y = -5.0\n\n    def add_layer(self, layer):\n        """Add a costmap layer"""\n        self.layers.append(layer)\n\n    def update_map(self):\n        """Update the master costmap by combining all layers"""\n        if not self.layers:\n            return\n\n        # Initialize master costmap if needed\n        if self.master_costmap is None:\n            self.master_costmap = Costmap2D(\n                resolution=self.resolution,\n                width=self.width,\n                height=self.height,\n                origin_x=self.origin_x,\n                origin_y=self.origin_y\n            )\n\n        # Reset master costmap\n        self.master_costmap.costmap.fill(self.master_costmap.COST_FREE)\n\n        # Combine all layers\n        for layer in self.layers:\n            self.combine_layers(layer)\n\n    def combine_layers(self, layer):\n        """Combine a layer with the master costmap"""\n        # This is a simplified combination - real implementation would be more complex\n        # For now, we\'ll just take the maximum cost at each cell\n        if hasattr(layer, \'costmap\'):\n            for i in range(min(self.master_costmap.height, layer.height)):\n                for j in range(min(self.master_costmap.width, layer.width)):\n                    current_cost = self.master_costmap.costmap[i, j]\n                    layer_cost = layer.costmap[i, j]\n                    self.master_costmap.costmap[i, j] = max(current_cost, layer_cost)\n\nclass StaticLayer:\n    """\n    Static layer for costmap - represents permanent obstacles like walls\n    """\n\n    def __init__(self, static_map: OccupancyGrid):\n        self.static_map = static_map\n        self.costmap = self.convert_occupancy_grid(static_map)\n\n    def convert_occupancy_grid(self, grid: OccupancyGrid):\n        """Convert OccupancyGrid message to costmap array"""\n        width = grid.info.width\n        height = grid.info.height\n        resolution = grid.info.resolution\n\n        # Create numpy array from the data\n        costmap = np.array(grid.data, dtype=np.int8).reshape((height, width))\n\n        return costmap\n\nclass ObstacleLayer:\n    """\n    Obstacle layer for costmap - represents dynamic obstacles from sensors\n    """\n\n    def __init__(self, observation_sources: List[str] = None):\n        self.observation_sources = observation_sources or []\n        self.costmap = None\n        self.observations = []\n        self.marking_radius = 0.5  # meters\n        self.clearing_radius = 1.0  # meters\n\n    def update_observations(self, observations: List):\n        """Update with new sensor observations"""\n        self.observations = observations\n\n    def ray_trace(self, start_x, start_y, end_x, end_y, clear: bool = False):\n        """Ray trace to mark or clear space"""\n        # Implementation for ray tracing\n        pass\n'})}),"\n",(0,o.jsx)(n.h2,{id:"global-path-planning",children:"Global Path Planning"}),"\n",(0,o.jsx)(n.p,{children:"Global path planning involves finding an optimal path from the start to the goal considering the static map and known obstacles. For humanoid robots, this must account for their specific locomotion capabilities and constraints."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import heapq\nfrom typing import List, Tuple, Dict, Optional\nimport math\n\nclass AStarPlanner:\n    """\n    A* path planning algorithm for humanoid robots\n    """\n\n    def __init__(self, costmap: Costmap2D):\n        self.costmap = costmap\n        self.motion_model = self.create_motion_model()\n\n    def create_motion_model(self) -> List[Tuple[int, int, float]]:\n        """\n        Create motion model for path planning\n        For humanoid robots, we might include specific motions like stepping patterns\n        """\n        # 8-connectivity motion model with different costs for different directions\n        motion = [\n            (1, 0, 1.0),    # East\n            (0, 1, 1.0),    # North\n            (-1, 0, 1.0),   # West\n            (0, -1, 1.0),   # South\n            (1, 1, math.sqrt(2)),   # Northeast\n            (-1, 1, math.sqrt(2)),  # Northwest\n            (-1, -1, math.sqrt(2)), # Southwest\n            (1, -1, math.sqrt(2))   # Southeast\n        ]\n        return motion\n\n    def plan(self, start: Tuple[float, float],\n             goal: Tuple[float, float]) -> Optional[List[Tuple[float, float]]]:\n        """\n        Plan path using A* algorithm\n        """\n        # Convert world coordinates to map coordinates\n        start_map = self.costmap.world_to_map(start[0], start[1])\n        goal_map = self.costmap.world_to_map(goal[0], goal[1])\n\n        # Validate start and goal\n        if not self.costmap.is_valid_cell(start_map[0], start_map[1]) or \\\n           not self.costmap.is_valid_cell(goal_map[0], goal_map[1]):\n            return None\n\n        if self.costmap.is_occupied(start[0], start[1]) or \\\n           self.costmap.is_occupied(goal[0], goal[1]):\n            return None\n\n        # Initialize open and closed sets\n        open_set = [(0, start_map)]\n        came_from: Dict[Tuple[int, int], Tuple[int, int]] = {}\n        g_score: Dict[Tuple[int, int], float] = {start_map: 0}\n        f_score: Dict[Tuple[int, int], float] = {start_map: self.heuristic(start_map, goal_map)}\n\n        # Convert open_set to a heap\n        heapq.heapify(open_set)\n        open_set_hash = {start_map}\n\n        while open_set:\n            current = heapq.heappop(open_set)\n            current_pos = current[1]\n            open_set_hash.remove(current_pos)\n\n            # Check if we reached the goal\n            if current_pos == goal_map:\n                return self.reconstruct_path(came_from, current_pos)\n\n            # Explore neighbors\n            for motion in self.motion_model:\n                neighbor = (current_pos[0] + motion[0], current_pos[1] + motion[1])\n\n                # Check if neighbor is valid\n                if not self.costmap.is_valid_cell(neighbor[0], neighbor[1]):\n                    continue\n\n                # Check if neighbor is occupied\n                neighbor_world = self.costmap.map_to_world(neighbor[0], neighbor[1])\n                if self.costmap.is_occupied(neighbor_world[0], neighbor_world[1]):\n                    continue\n\n                # Calculate tentative g_score\n                tentative_g_score = g_score[current_pos] + motion[2]  # distance cost\n                cost_at_neighbor = self.get_cell_cost(neighbor)\n                movement_cost = tentative_g_score + cost_at_neighbor * 0.1  # cost penalty\n\n                # If this path to neighbor is better\n                if neighbor not in g_score or movement_cost < g_score[neighbor]:\n                    came_from[neighbor] = current_pos\n                    g_score[neighbor] = movement_cost\n                    f_score[neighbor] = movement_cost + self.heuristic(neighbor, goal_map)\n\n                    if neighbor not in open_set_hash:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                        open_set_hash.add(neighbor)\n\n        # No path found\n        return None\n\n    def get_cell_cost(self, pos: Tuple[int, int]) -> float:\n        """Get cost of traversing a cell"""\n        world_pos = self.costmap.map_to_world(pos[0], pos[1])\n        cost = self.costmap.get_cost(world_pos[0], world_pos[1])\n        return max(0, cost / 100.0)  # Normalize cost to 0-1 range\n\n    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n        """Calculate heuristic (Euclidean distance)"""\n        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\n\n    def reconstruct_path(self, came_from: Dict, current: Tuple[int, int]) -> List[Tuple[float, float]]:\n        """Reconstruct path from came_from map"""\n        path = [self.costmap.map_to_world(current[0], current[1])]\n\n        while current in came_from:\n            current = came_from[current]\n            world_pos = self.costmap.map_to_world(current[0], current[1])\n            path.append(world_pos)\n\n        path.reverse()\n        return path\n\nclass DijkstraPlanner(AStarPlanner):\n    """\n    Dijkstra\'s algorithm for path planning (special case of A* with no heuristic)\n    """\n\n    def heuristic(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:\n        """No heuristic for Dijkstra"""\n        return 0.0\n\nclass HumanoidPathOptimizer:\n    """\n    Path optimizer for humanoid robots that smooths paths and considers step constraints\n    """\n\n    def __init__(self, step_length: float = 0.3, max_lean_angle: float = 0.2):\n        self.step_length = step_length\n        self.max_lean_angle = max_lean_angle\n\n    def optimize_path(self, path: List[Tuple[float, float]]) -> List[Tuple[float, float]]:\n        """Optimize path for humanoid locomotion"""\n        if len(path) < 3:\n            return path\n\n        # Apply path smoothing\n        smoothed_path = self.smooth_path(path)\n\n        # Resample path to appropriate step lengths\n        resampled_path = self.resample_path(smoothed_path, self.step_length)\n\n        return resampled_path\n\n    def smooth_path(self, path: List[Tuple[float, float]],\n                   weight_data: float = 0.5, weight_smooth: float = 0.1,\n                   tolerance: float = 0.00001) -> List[Tuple[float, float]]:\n        """Smooth path using gradient descent"""\n        if len(path) < 3:\n            return path\n\n        # Create a copy of the path\n        new_path = [list(point) for point in path]\n\n        change = tolerance\n        while change >= tolerance:\n            change = 0.0\n            for i in range(1, len(path) - 1):\n                for j in range(len(path[0])):  # x, y coordinates\n                    aux = new_path[i][j]\n                    # Update based on original path and neighbors\n                    new_path[i][j] += weight_data * (path[i][j] - new_path[i][j])\n                    new_path[i][j] += weight_smooth * (new_path[i-1][j] + new_path[i+1][j] - 2.0 * new_path[i][j])\n                    change += abs(aux - new_path[i][j])\n\n        return [tuple(point) for point in new_path]\n\n    def resample_path(self, path: List[Tuple[float, float]],\n                     step_length: float) -> List[Tuple[float, float]]:\n        """Resample path to have consistent step lengths"""\n        if len(path) < 2:\n            return path\n\n        resampled_path = [path[0]]\n\n        for i in range(1, len(path)):\n            prev_point = path[i-1]\n            curr_point = path[i]\n\n            # Calculate distance between points\n            dist = math.sqrt((curr_point[0] - prev_point[0])**2 +\n                           (curr_point[1] - prev_point[1])**2)\n\n            # If distance is greater than step length, add intermediate points\n            if dist > step_length:\n                num_steps = int(dist / step_length)\n                for j in range(1, num_steps + 1):\n                    t = j / num_steps\n                    x = prev_point[0] + t * (curr_point[0] - prev_point[0])\n                    y = prev_point[1] + t * (curr_point[1] - prev_point[1])\n                    resampled_path.append((x, y))\n            else:\n                resampled_path.append(curr_point)\n\n        return resampled_path\n\nclass GlobalPlannerNode(Node):\n    """\n    ROS 2 node for global path planning\n    """\n\n    def __init__(self):\n        super().__init__(\'global_planner\')\n\n        # Parameters\n        self.declare_parameter(\'planner_type\', \'astar\')\n        self.declare_parameter(\'step_length\', 0.3)\n        self.declare_parameter(\'max_lean_angle\', 0.2)\n\n        self.planner_type = self.get_parameter(\'planner_type\').value\n        self.step_length = self.get_parameter(\'step_length\').value\n        self.max_lean_angle = self.get_parameter(\'max_lean_angle\').value\n\n        # Initialize planner\n        self.costmap = None\n        self.planner = None\n        self.path_optimizer = HumanoidPathOptimizer(\n            step_length=self.step_length,\n            max_lean_angle=self.max_lean_angle\n        )\n\n        # Publishers and subscribers\n        self.path_pub = self.create_publisher(Path, \'global_plan\', 10)\n        self.map_sub = self.create_subscription(\n            OccupancyGrid, \'map\', self.map_callback, 10)\n\n        # Service server for planning\n        from rclpy.qos import QoSProfile\n        self.plan_srv = self.create_service(\n            # We\'d use the actual Nav2 service type here\n            # For this example, we\'ll use a placeholder\n        )\n\n    def map_callback(self, msg: OccupancyGrid):\n        """Handle map updates"""\n        self.costmap = StaticLayer(msg).costmap\n        # Initialize planner with new costmap\n        if self.planner_type == \'astar\':\n            self.planner = AStarPlanner(self.costmap)\n        else:\n            self.planner = DijkstraPlanner(self.costmap)\n\n    def plan_path(self, start: Tuple[float, float],\n                 goal: Tuple[float, float]) -> Optional[List[Tuple[float, float]]]:\n        """Plan path from start to goal"""\n        if not self.planner:\n            return None\n\n        # Plan path\n        raw_path = self.planner.plan(start, goal)\n\n        if not raw_path:\n            return None\n\n        # Optimize path for humanoid\n        optimized_path = self.path_optimizer.optimize_path(raw_path)\n\n        return optimized_path\n\ndef create_global_planner():\n    """Factory function to create a global planner"""\n    rclpy.init()\n    node = GlobalPlannerNode()\n    return node\n'})}),"\n",(0,o.jsx)(n.h2,{id:"local-path-planning",children:"Local Path Planning"}),"\n",(0,o.jsx)(n.p,{children:"Local path planning focuses on executing the global plan while avoiding dynamic obstacles and adjusting to real-time sensor data. For humanoid robots, this involves careful consideration of balance and step planning."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from typing import List, Tuple, Optional\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\nclass LocalPlanner:\n    """\n    Local path planning for humanoid robots with obstacle avoidance\n    """\n\n    def __init__(self,\n                 max_vel_x: float = 0.5,\n                 min_vel_x: float = 0.1,\n                 max_vel_theta: float = 1.0,\n                 acc_lim_x: float = 2.5,\n                 acc_lim_theta: float = 3.2,\n                 xy_goal_tolerance: float = 0.25,\n                 yaw_goal_tolerance: float = 0.25):\n\n        self.max_vel_x = max_vel_x\n        self.min_vel_x = min_vel_x\n        self.max_vel_theta = max_vel_theta\n        self.acc_lim_x = acc_lim_x\n        self.acc_lim_theta = acc_lim_theta\n        self.xy_goal_tolerance = xy_goal_tolerance\n        self.yaw_goal_tolerance = yaw_goal_tolerance\n\n        # Robot state\n        self.current_pose = None\n        self.current_velocity = Twist()\n        self.global_plan = []\n        self.local_plan = []\n\n        # Costmap\n        self.costmap = None\n\n        # Trajectory sampling parameters\n        self.sim_time = 1.7  # seconds to simulate\n        self.vx_samples = 3  # number of x velocity samples\n        self.vtheta_samples = 20  # number of theta velocity samples\n\n    def set_global_plan(self, plan: List[Tuple[float, float]]):\n        """Set the global plan to follow"""\n        self.global_plan = plan\n        self.local_plan = self.get_local_plan_segment()\n\n    def get_local_plan_segment(self) -> List[Tuple[float, float]]:\n        """Get the segment of the global plan to consider for local planning"""\n        if not self.global_plan or not self.current_pose:\n            return []\n\n        # Find the closest point on the global plan\n        closest_idx = self.find_closest_point_on_plan()\n        if closest_idx is None:\n            return []\n\n        # Return next N points as local plan\n        look_ahead_points = 10  # Consider next 10 points\n        end_idx = min(closest_idx + look_ahead_points, len(self.global_plan))\n\n        return self.global_plan[closest_idx:end_idx]\n\n    def find_closest_point_on_plan(self) -> Optional[int]:\n        """Find the closest point on the global plan to current pose"""\n        if not self.global_plan or not self.current_pose:\n            return None\n\n        robot_x = self.current_pose.pose.position.x\n        robot_y = self.current_pose.pose.position.y\n\n        min_dist = float(\'inf\')\n        closest_idx = 0\n\n        for i, (x, y) in enumerate(self.global_plan):\n            dist = math.sqrt((x - robot_x)**2 + (y - robot_y)**2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        return closest_idx if min_dist < float(\'inf\') else None\n\n    def compute_velocity_commands(self) -> List[Tuple[float, float, float]]:\n        """\n        Compute possible velocity commands using sampling\n        Returns list of (vx, vy, vtheta) tuples\n        """\n        if not self.current_velocity:\n            return []\n\n        # Current velocities\n        current_vx = self.current_velocity.linear.x\n        current_vtheta = self.current_velocity.angular.z\n\n        # Calculate velocity ranges based on acceleration limits\n        dt = 0.1  # time step\n        max_vx = min(self.max_vel_x,\n                    current_vx + self.acc_lim_x * dt)\n        min_vx = max(self.min_vel_x,\n                    current_vx - self.acc_lim_x * dt)\n\n        max_vtheta = min(self.max_vel_theta,\n                        current_vtheta + self.acc_lim_theta * dt)\n        min_vtheta = max(-self.max_vel_theta,\n                        current_vtheta - self.acc_lim_theta * dt)\n\n        # Generate samples\n        vx_samples = np.linspace(min_vx, max_vx, self.vx_samples)\n        vtheta_samples = np.linspace(min_vtheta, max_vtheta, self.vtheta_samples)\n\n        commands = []\n        for vx in vx_samples:\n            for vtheta in vtheta_samples:\n                commands.append((vx, 0.0, vtheta))  # vy is 0 for differential drive\n\n        return commands\n\n    def evaluate_trajectory(self, vx: float, vy: float, vtheta: float) -> float:\n        """\n        Evaluate a trajectory based on multiple criteria\n        Higher score is better\n        """\n        if not self.costmap or not self.current_pose:\n            return -float(\'inf\')\n\n        # Simulate trajectory\n        trajectory = self.simulate_trajectory(vx, vy, vtheta)\n\n        if not trajectory:\n            return -float(\'inf\')\n\n        # Evaluate multiple criteria\n        goal_distance_score = self.evaluate_goal_distance(trajectory)\n        obstacle_score = self.evaluate_obstacle_clearance(trajectory)\n        path_alignment_score = self.evaluate_path_alignment(trajectory)\n\n        # Weighted combination of scores\n        total_score = (0.4 * goal_distance_score +\n                      0.4 * obstacle_score +\n                      0.2 * path_alignment_score)\n\n        return total_score\n\n    def simulate_trajectory(self, vx: float, vy: float, vtheta: float) -> List[Tuple[float, float]]:\n        """Simulate a trajectory over time"""\n        if not self.current_pose:\n            return []\n\n        robot_x = self.current_pose.pose.position.x\n        robot_y = self.current_pose.pose.position.y\n        robot_yaw = self.get_yaw_from_quaternion(self.current_pose.pose.orientation)\n\n        dt = 0.1  # time step\n        num_steps = int(self.sim_time / dt)\n\n        trajectory = [(robot_x, robot_y)]\n\n        for i in range(num_steps):\n            # Update orientation\n            robot_yaw += vtheta * dt\n\n            # Update position\n            robot_x += (vx * math.cos(robot_yaw) - vy * math.sin(robot_yaw)) * dt\n            robot_y += (vx * math.sin(robot_yaw) + vy * math.cos(robot_yaw)) * dt\n\n            trajectory.append((robot_x, robot_y))\n\n        return trajectory\n\n    def evaluate_goal_distance(self, trajectory: List[Tuple[float, float]]) -> float:\n        """Evaluate how close the trajectory gets to the goal"""\n        if not self.global_plan:\n            return 0.0\n\n        # Get the last point in the global plan (goal)\n        goal_x, goal_y = self.global_plan[-1]\n\n        # Get the last point in the trajectory\n        traj_x, traj_y = trajectory[-1]\n\n        # Calculate distance to goal\n        dist = math.sqrt((goal_x - traj_x)**2 + (goal_y - traj_y)**2)\n\n        # Score: higher for closer to goal (inverse relationship)\n        return max(0.0, 1.0 - dist / 10.0)  # Normalize assuming max 10m distance\n\n    def evaluate_obstacle_clearance(self, trajectory: List[Tuple[float, float]]) -> float:\n        """Evaluate how well the trajectory avoids obstacles"""\n        if not self.costmap:\n            return 0.0\n\n        min_clearance = float(\'inf\')\n\n        for x, y in trajectory:\n            cost = self.costmap.get_cost(x, y)\n            if cost >= self.costmap.COST_INSCRIBED:\n                # Trajectory hits obstacle\n                return -1.0\n\n        # If no obstacles hit, return positive score based on clearance\n        # For simplicity, we\'ll return a high score if no obstacles are hit\n        return 1.0\n\n    def evaluate_path_alignment(self, trajectory: List[Tuple[float, float]]) -> float:\n        """Evaluate how well the trajectory follows the global path"""\n        if not self.global_plan or len(self.global_plan) < 2:\n            return 0.0\n\n        total_score = 0.0\n\n        for i, (traj_x, traj_y) in enumerate(trajectory):\n            # Find closest point on global plan\n            min_dist = float(\'inf\')\n            for plan_x, plan_y in self.global_plan:\n                dist = math.sqrt((plan_x - traj_x)**2 + (plan_y - traj_y)**2)\n                if dist < min_dist:\n                    min_dist = dist\n\n            # Score based on distance to global plan (lower distance = higher score)\n            score = max(0.0, 1.0 - min_dist / 2.0)  # Normalize with 2m threshold\n            total_score += score\n\n        # Average score over trajectory length\n        return total_score / len(trajectory) if trajectory else 0.0\n\n    def get_best_cmd_vel(self) -> Optional[Twist]:\n        """Get the best velocity command based on trajectory evaluation"""\n        if not self.local_plan:\n            return None\n\n        # Get possible commands\n        commands = self.compute_velocity_commands()\n\n        if not commands:\n            return None\n\n        # Evaluate each command\n        best_score = -float(\'inf\')\n        best_cmd = None\n\n        for vx, vy, vtheta in commands:\n            score = self.evaluate_trajectory(vx, vy, vtheta)\n            if score > best_score:\n                best_score = score\n                best_cmd = (vx, vy, vtheta)\n\n        if best_cmd:\n            cmd_vel = Twist()\n            cmd_vel.linear.x = best_cmd[0]\n            cmd_vel.linear.y = best_cmd[1]\n            cmd_vel.angular.z = best_cmd[2]\n            return cmd_vel\n\n        return None\n\n    def update_costmap_with_scan(self, scan: LaserScan):\n        """Update costmap with laser scan data"""\n        if self.costmap:\n            # This would update the costmap with scan data\n            # Implementation depends on the specific costmap structure\n            pass\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\nclass HumanoidLocalPlanner(LocalPlanner):\n    """\n    Humanoid-specific local planner that considers balance and step constraints\n    """\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        # Humanoid-specific parameters\n        self.step_length = 0.3  # meters\n        self.step_duration = 0.5  # seconds\n        self.max_lean_angle = 0.2  # radians\n        self.balance_margin = 0.1  # safety margin for balance\n\n        # Balance controller\n        self.balance_controller = BalanceController()\n\n    def evaluate_trajectory(self, vx: float, vy: float, vtheta: float) -> float:\n        """Humanoid-specific trajectory evaluation"""\n        # Start with base evaluation\n        base_score = super().evaluate_trajectory(vx, vy, vtheta)\n\n        # Add humanoid-specific constraints\n        balance_score = self.evaluate_balance_constraints(vx, vtheta)\n        step_feasibility_score = self.evaluate_step_feasibility(vx, vtheta)\n\n        # Weighted combination\n        total_score = (0.5 * base_score +\n                      0.3 * balance_score +\n                      0.2 * step_feasibility_score)\n\n        return total_score\n\n    def evaluate_balance_constraints(self, vx: float, vtheta: float) -> float:\n        """Evaluate if the command violates balance constraints"""\n        # Calculate if the velocity command would cause instability\n        max_stable_linear = self.balance_controller.calculate_max_stable_linear_velocity()\n        max_stable_angular = self.balance_controller.calculate_max_stable_angular_velocity()\n\n        if abs(vx) > max_stable_linear or abs(vtheta) > max_stable_angular:\n            return -1.0  # Invalid command\n        else:\n            # Score based on how close to limits\n            linear_ratio = abs(vx) / max_stable_linear\n            angular_ratio = abs(vtheta) / max_stable_angular\n            max_ratio = max(linear_ratio, angular_ratio)\n\n            # Higher score for commands further from limits\n            return max(0.0, 1.0 - max_ratio)\n\n    def evaluate_step_feasibility(self, vx: float, vtheta: float) -> float:\n        """Evaluate if the command allows for feasible stepping"""\n        # Calculate step frequency based on velocity\n        step_freq = abs(vx) / self.step_length if abs(vx) > 0.01 else 0.0\n\n        # Check if step frequency is within feasible range\n        max_step_freq = 1.0 / (self.step_duration * 0.8)  # 80% of step duration\n        if step_freq > max_step_freq:\n            return 0.0  # Too fast for feasible steps\n\n        # Higher score for moderate step frequencies\n        ideal_freq = 0.5 * max_step_freq\n        freq_ratio = step_freq / ideal_freq\n        if freq_ratio <= 1.0:\n            return 1.0  # Good frequency\n        else:\n            return max(0.0, 2.0 - freq_ratio)  # Decreasing score for higher frequencies\n'})}),"\n",(0,o.jsx)(n.h2,{id:"controller-plugins",children:"Controller Plugins"}),"\n",(0,o.jsx)(n.p,{children:"Controller plugins in Nav2 handle the conversion of planned paths into actual velocity commands. For humanoid robots, this involves complex control strategies to maintain balance while following paths."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'from typing import List, Tuple, Optional\nimport numpy as np\nfrom scipy.interpolate import interp1d\nfrom geometry_msgs.msg import Twist, PoseStamped\nimport math\n\nclass ControllerBase:\n    """\n    Base class for controller plugins\n    """\n\n    def __init__(self, name: str):\n        self.name = name\n        self.initialized = False\n\n    def set_plan(self, path: List[PoseStamped]):\n        """Set the plan to follow"""\n        raise NotImplementedError\n\n    def compute_velocity_command(self, robot_pose, robot_velocity) -> Optional[Twist]:\n        """Compute the next velocity command"""\n        raise NotImplementedError\n\n    def is_goal_reached(self) -> bool:\n        """Check if the goal has been reached"""\n        raise NotImplementedError\n\nclass PIDController(ControllerBase):\n    """\n    PID-based path following controller\n    """\n\n    def __init__(self, name: str = "PIDController"):\n        super().__init__(name)\n\n        # PID gains\n        self.kp_linear = 1.0  # Proportional gain for linear velocity\n        self.ki_linear = 0.0  # Integral gain for linear velocity\n        self.kd_linear = 0.1  # Derivative gain for linear velocity\n\n        self.kp_angular = 2.0  # Proportional gain for angular velocity\n        self.ki_angular = 0.0  # Integral gain for angular velocity\n        self.kd_angular = 0.2  # Derivative gain for angular velocity\n\n        # Controller state\n        self.linear_error_integral = 0.0\n        self.angular_error_integral = 0.0\n        self.prev_linear_error = 0.0\n        self.prev_angular_error = 0.0\n        self.prev_time = None\n\n        # Robot parameters\n        self.max_linear_vel = 0.5\n        self.max_angular_vel = 1.0\n        self.min_linear_vel = 0.1\n        self.xy_goal_tolerance = 0.25\n        self.yaw_goal_tolerance = 0.25\n\n        # Plan\n        self.path = []\n        self.current_waypoint_idx = 0\n\n        self.initialized = True\n\n    def set_plan(self, path: List[PoseStamped]):\n        """Set the plan to follow"""\n        self.path = path\n        self.current_waypoint_idx = 0\n        self.reset_integrals()\n\n    def reset_integrals(self):\n        """Reset integral terms"""\n        self.linear_error_integral = 0.0\n        self.angular_error_integral = 0.0\n        self.prev_linear_error = 0.0\n        self.prev_angular_error = 0.0\n        self.prev_time = None\n\n    def compute_velocity_command(self, robot_pose, robot_velocity) -> Optional[Twist]:\n        """Compute velocity command using PID control"""\n        if not self.path or self.current_waypoint_idx >= len(self.path):\n            return None\n\n        # Get current time\n        current_time = time.time()\n        if self.prev_time is None:\n            dt = 0.1  # Default time step\n        else:\n            dt = current_time - self.prev_time\n\n        self.prev_time = current_time\n\n        # Get current robot position and orientation\n        robot_x = robot_pose.pose.position.x\n        robot_y = robot_pose.pose.position.y\n        robot_yaw = self.get_yaw_from_quaternion(robot_pose.pose.orientation)\n\n        # Get target waypoint\n        target_pose = self.path[self.current_waypoint_idx]\n        target_x = target_pose.pose.position.x\n        target_y = target_pose.pose.position.y\n\n        # Calculate errors\n        dx = target_x - robot_x\n        dy = target_y - robot_y\n        target_distance = math.sqrt(dx**2 + dy**2)\n\n        target_angle = math.atan2(dy, dx)\n        angle_error = target_angle - robot_yaw\n\n        # Normalize angle error\n        while angle_error > math.pi:\n            angle_error -= 2 * math.pi\n        while angle_error < -math.pi:\n            angle_error += 2 * math.pi\n\n        # PID control for linear velocity\n        linear_error = target_distance\n        self.linear_error_integral += linear_error * dt\n        linear_error_derivative = (linear_error - self.prev_linear_error) / dt if dt > 0 else 0\n\n        linear_vel = (self.kp_linear * linear_error +\n                     self.ki_linear * self.linear_error_integral +\n                     self.kd_linear * linear_error_derivative)\n\n        # Limit linear velocity\n        linear_vel = max(self.min_linear_vel, min(self.max_linear_vel, abs(linear_vel)))\n\n        # PID control for angular velocity\n        angular_error = angle_error\n        self.angular_error_integral += angular_error * dt\n        angular_error_derivative = (angular_error - self.prev_angular_error) / dt if dt > 0 else 0\n\n        angular_vel = (self.kp_angular * angular_error +\n                      self.ki_angular * self.angular_error_integral +\n                      self.kd_angular * angular_error_derivative)\n\n        # Limit angular velocity\n        angular_vel = max(-self.max_angular_vel, min(self.max_angular_vel, angular_vel))\n\n        # Update previous errors\n        self.prev_linear_error = linear_error\n        self.prev_angular_error = angular_error\n\n        # Create command\n        cmd_vel = Twist()\n        cmd_vel.linear.x = linear_vel\n        cmd_vel.angular.z = angular_vel\n\n        # Check if we\'ve reached the current waypoint\n        if target_distance < 0.5:  # Waypoint reached threshold\n            self.current_waypoint_idx += 1\n            if self.current_waypoint_idx >= len(self.path):\n                # Path completed, slow down\n                cmd_vel.linear.x = 0.0\n                cmd_vel.angular.z = 0.0\n\n        return cmd_vel\n\n    def is_goal_reached(self) -> bool:\n        """Check if the goal has been reached"""\n        if not self.path or self.current_waypoint_idx >= len(self.path):\n            return True  # Path completed\n\n        # Check if we\'re at the last waypoint\n        if self.current_waypoint_idx == len(self.path) - 1:\n            # Check distance to final goal\n            if hasattr(self, \'robot_pose\'):\n                robot_x = self.robot_pose.pose.position.x\n                robot_y = self.robot_pose.pose.position.y\n                goal_x = self.path[-1].pose.position.x\n                goal_y = self.path[-1].pose.position.y\n                distance = math.sqrt((goal_x - robot_x)**2 + (goal_y - robot_y)**2)\n                return distance <= self.xy_goal_tolerance\n\n        return False\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\nclass HumanoidMPCController(ControllerBase):\n    """\n    Model Predictive Control (MPC) controller for humanoid robots\n    """\n\n    def __init__(self, name: str = "HumanoidMPCController"):\n        super().__init__(name)\n\n        # MPC parameters\n        self.horizon = 10  # prediction horizon steps\n        self.dt = 0.1      # time step (seconds)\n\n        # Robot parameters for inverted pendulum model\n        self.com_height = 0.8  # Center of mass height (m)\n        self.gravity = 9.81    # Gravity constant\n\n        # Weights for MPC cost function\n        self.state_weight = np.diag([1.0, 1.0, 0.5, 0.5])  # [x, y, vx, vy]\n        self.control_weight = np.diag([0.1, 0.1])  # [vx_cmd, vy_cmd]\n        self.terminal_weight = np.diag([5.0, 5.0, 1.0, 1.0])\n\n        # Robot constraints\n        self.max_linear_vel = 0.5\n        self.max_angular_vel = 1.0\n        self.max_accel = 1.0\n\n        # Goal tolerance\n        self.xy_goal_tolerance = 0.25\n        self.yaw_goal_tolerance = 0.25\n\n        # Internal state\n        self.path = []\n        self.current_waypoint_idx = 0\n        self.initialized = True\n\n    def set_plan(self, path: List[PoseStamped]):\n        """Set the plan to follow"""\n        self.path = path\n        self.current_waypoint_idx = 0\n\n    def compute_velocity_command(self, robot_pose, robot_velocity) -> Optional[Twist]:\n        """Compute velocity command using MPC"""\n        if not self.path or self.current_waypoint_idx >= len(self.path):\n            return None\n\n        # Get robot state\n        robot_x = robot_pose.pose.position.x\n        robot_y = robot_pose.pose.position.y\n        robot_yaw = self.get_yaw_from_quaternion(robot_pose.pose.orientation)\n\n        robot_vx = robot_velocity.linear.x\n        robot_vy = robot_velocity.linear.y\n        robot_vyaw = robot_velocity.angular.z\n\n        # Get reference trajectory for the horizon\n        reference_trajectory = self.get_reference_trajectory(\n            robot_x, robot_y, robot_yaw, robot_vx, robot_vy\n        )\n\n        # Solve MPC optimization problem\n        optimal_control = self.solve_mpc(\n            robot_x, robot_y, robot_vx, robot_vy,\n            reference_trajectory\n        )\n\n        if optimal_control is not None:\n            cmd_vel = Twist()\n            cmd_vel.linear.x = optimal_control[0]\n            cmd_vel.linear.y = optimal_control[1]\n            cmd_vel.angular.z = self.calculate_angular_velocity(\n                robot_yaw, robot_vx, robot_vy, optimal_control[0], optimal_control[1]\n            )\n            return cmd_vel\n\n        return None\n\n    def get_reference_trajectory(self, x, y, yaw, vx, vy):\n        """Get reference trajectory for MPC"""\n        ref_traj = []\n\n        # Find closest point on path\n        closest_idx = self.find_closest_waypoint(x, y)\n        if closest_idx is None:\n            return ref_traj\n\n        # Generate reference points along the path\n        for i in range(self.horizon):\n            future_idx = min(closest_idx + i * 2, len(self.path) - 1)\n            pose = self.path[future_idx]\n            ref_traj.append([\n                pose.pose.position.x,\n                pose.pose.position.y,\n                0.0,  # reference velocity x\n                0.0   # reference velocity y\n            ])\n\n        return ref_traj\n\n    def find_closest_waypoint(self, x, y):\n        """Find the closest waypoint on the path"""\n        min_dist = float(\'inf\')\n        closest_idx = 0\n\n        for i, pose in enumerate(self.path):\n            dist = math.sqrt(\n                (pose.pose.position.x - x)**2 +\n                (pose.pose.position.y - y)**2\n            )\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        return closest_idx if min_dist < float(\'inf\') else None\n\n    def solve_mpc(self, x, y, vx, vy, reference_trajectory):\n        """Solve the MPC optimization problem (simplified implementation)"""\n        # This is a simplified MPC implementation\n        # In a real implementation, you would use a proper optimization solver\n\n        # For this example, we\'ll use a simple approach to compute control\n        if not reference_trajectory:\n            return None\n\n        # Get first reference point\n        ref_x, ref_y, ref_vx, ref_vy = reference_trajectory[0]\n\n        # Simple proportional control to reach reference point\n        error_x = ref_x - x\n        error_y = ref_y - y\n\n        # Compute desired velocity to reduce error\n        desired_vx = 0.5 * error_x  # Simple proportional control\n        desired_vy = 0.5 * error_y\n\n        # Apply velocity limits\n        desired_vx = max(-self.max_linear_vel, min(self.max_linear_vel, desired_vx))\n        desired_vy = max(-self.max_linear_vel, min(self.max_linear_vel, desired_vy))\n\n        # Ensure forward motion if moving toward goal\n        if math.sqrt(error_x**2 + error_y**2) > 0.1:  # If not very close to goal\n            desired_vx = max(0.1, desired_vx)  # Ensure minimum forward speed\n\n        return [desired_vx, desired_vy]\n\n    def calculate_angular_velocity(self, current_yaw, current_vx, current_vy,\n                                 desired_vx, desired_vy):\n        """Calculate required angular velocity to orient correctly"""\n        if abs(current_vx) < 0.01 and abs(current_vy) < 0.01:\n            return 0.0  # Not moving, no angular correction needed\n\n        # Calculate desired heading based on velocity\n        desired_yaw = math.atan2(desired_vy, desired_vx)\n        yaw_error = desired_yaw - current_yaw\n\n        # Normalize angle\n        while yaw_error > math.pi:\n            yaw_error -= 2 * math.pi\n        while yaw_error < -math.pi:\n            yaw_error += 2 * math.pi\n\n        # Proportional control for angular velocity\n        return 1.0 * yaw_error  # Simple proportional controller\n\n    def is_goal_reached(self) -> bool:\n        """Check if the goal has been reached"""\n        if not self.path:\n            return True\n\n        if self.current_waypoint_idx >= len(self.path):\n            return True\n\n        # Check if at final waypoint\n        if self.current_waypoint_idx == len(self.path) - 1:\n            # Check distance to final goal\n            # This would be implemented based on robot pose\n            pass\n\n        return False\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\nclass FootstepController:\n    """\n    Controller that generates footstep plans for humanoid locomotion\n    """\n\n    def __init__(self):\n        self.step_length = 0.3  # meters\n        self.step_duration = 0.5  # seconds\n        self.step_height = 0.05   # meters\n        self.com_height = 0.8     # Center of mass height\n        self.zmp_margin = 0.05    # ZMP safety margin\n\n        # Robot foot parameters\n        self.foot_length = 0.25   # meters\n        self.foot_width = 0.15    # meters\n        self.foot_separation = 0.2  # distance between feet (shoulder width equivalent)\n\n    def plan_footsteps(self, path, robot_pose, robot_velocity):\n        """Plan footsteps along the given path"""\n        footsteps = []\n\n        if not path:\n            return footsteps\n\n        # Start from current robot position\n        current_x = robot_pose.pose.position.x\n        current_y = robot_pose.pose.position.y\n        current_yaw = self.get_yaw_from_quaternion(robot_pose.pose.orientation)\n\n        # Determine starting foot (left or right)\n        use_left_foot = True  # Alternate for walking pattern\n\n        # Generate footsteps along the path\n        for i in range(1, len(path)):\n            target_x = path[i].pose.position.x\n            target_y = path[i].pose.position.y\n\n            # Calculate direction to next waypoint\n            dx = target_x - current_x\n            dy = target_y - current_y\n            distance = math.sqrt(dx**2 + dy**2)\n\n            # Calculate number of steps needed\n            num_steps = max(1, int(distance / self.step_length))\n\n            for j in range(num_steps):\n                # Calculate intermediate position\n                step_ratio = (j + 1) / num_steps\n                step_x = current_x + step_ratio * dx\n                step_y = current_y + step_ratio * dy\n\n                # Offset for foot placement (alternating left/right)\n                if use_left_foot:\n                    # Left foot offset\n                    offset_x = -self.foot_separation/2 * math.sin(current_yaw)\n                    offset_y = self.foot_separation/2 * math.cos(current_yaw)\n                else:\n                    # Right foot offset\n                    offset_x = self.foot_separation/2 * math.sin(current_yaw)\n                    offset_y = -self.foot_separation/2 * math.cos(current_yaw)\n\n                foot_x = step_x + offset_x\n                foot_y = step_y + offset_y\n\n                # Create footstep pose\n                foot_pose = PoseStamped()\n                foot_pose.header.frame_id = "map"\n                foot_pose.pose.position.x = foot_x\n                foot_pose.pose.position.y = foot_y\n                foot_pose.pose.position.z = 0.0  # Ground level\n                foot_pose.pose.orientation = path[i].pose.orientation\n\n                footsteps.append(foot_pose)\n\n                # Switch feet for next step\n                use_left_foot = not use_left_foot\n\n            # Update current position for next segment\n            current_x = target_x\n            current_y = target_y\n\n        return footsteps\n\n    def execute_footstep(self, foot_pose):\n        """Execute a single footstep"""\n        # This would interface with the humanoid\'s motion controller\n        # to execute the footstep while maintaining balance\n        pass\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\nclass HumanoidController:\n    """\n    Main humanoid controller that coordinates balance, footsteps, and navigation\n    """\n\n    def __init__(self):\n        self.mpc_controller = HumanoidMPCController()\n        self.footstep_controller = FootstepController()\n        self.balance_controller = BalanceController()\n\n        # Navigation state\n        self.current_path = []\n        self.current_step = 0\n        self.is_balanced = True\n\n    def set_plan(self, path: List[PoseStamped]):\n        """Set the navigation plan"""\n        self.current_path = path\n        self.mpc_controller.set_plan(path)\n\n    def compute_velocity_command(self, robot_pose, robot_velocity) -> Optional[Twist]:\n        """Compute navigation command with balance considerations"""\n        # Get base velocity command from MPC controller\n        base_cmd = self.mpc_controller.compute_velocity_command(robot_pose, robot_velocity)\n\n        if base_cmd is None:\n            return None\n\n        # Apply balance constraints\n        balanced_cmd = self.balance_controller.apply_balance_constraints(base_cmd)\n\n        return balanced_cmd\n\n    def generate_footsteps(self, robot_pose):\n        """Generate footstep plan for the current path"""\n        return self.footstep_controller.plan_footsteps(\n            self.current_path, robot_pose, Twist()\n        )\n\n    def is_goal_reached(self) -> bool:\n        """Check if the goal has been reached"""\n        return self.mpc_controller.is_goal_reached()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"humanoid-specific-navigation",children:"Humanoid-Specific Navigation"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robot navigation presents unique challenges due to their bipedal locomotion, balance requirements, and complex kinematics. This section covers specialized approaches for humanoid navigation."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial.transform import Rotation as R\nfrom typing import List, Tuple, Optional\nimport casadi as ca\n\nclass HumanoidNavigationSystem:\n    """\n    Comprehensive navigation system for humanoid robots\n    """\n\n    def __init__(self):\n        # Robot physical parameters\n        self.com_height = 0.8  # Center of mass height (m)\n        self.leg_length = 0.9  # Leg length (m)\n        self.foot_length = 0.25  # Foot length (m)\n        self.foot_width = 0.15   # Foot width (m)\n\n        # Navigation parameters\n        self.step_length = 0.3   # Desired step length (m)\n        self.step_duration = 0.5 # Time per step (s)\n        self.max_lean_angle = 0.2 # Maximum lean angle (rad)\n\n        # Balance parameters\n        self.zmp_margin = 0.05   # ZMP safety margin (m)\n        self.max_com_velocity = 0.5  # Maximum CoM velocity (m/s)\n\n        # Controllers\n        self.path_follower = HumanoidMPCController()\n        self.balance_controller = BalanceController()\n        self.footstep_planner = FootstepController()\n\n        # Internal state\n        self.current_path = []\n        self.current_footsteps = []\n        self.balance_state = "stable"\n\n        self.initialized = True\n\n    def navigate_to_pose(self, goal_pose, robot_pose):\n        """\n        Navigate the humanoid robot to the goal pose\n        """\n        # Plan global path\n        global_path = self.plan_global_path(robot_pose, goal_pose)\n\n        if not global_path:\n            return False\n\n        # Generate footstep plan\n        footsteps = self.footstep_planner.plan_footsteps(\n            global_path, robot_pose, Twist()\n        )\n\n        if not footsteps:\n            return False\n\n        # Set the plan for execution\n        self.path_follower.set_plan(global_path)\n        self.current_path = global_path\n        self.current_footsteps = footsteps\n\n        # Execute navigation\n        return self.execute_navigation(robot_pose)\n\n    def plan_global_path(self, start_pose, goal_pose):\n        """\n        Plan global path considering humanoid constraints\n        """\n        # Use A* or other path planning algorithm\n        # For this example, we\'ll create a simple path\n        path = []\n\n        start_x = start_pose.pose.position.x\n        start_y = start_pose.pose.position.y\n        goal_x = goal_pose.pose.position.x\n        goal_y = goal_pose.pose.position.y\n\n        # Calculate distance\n        dist = math.sqrt((goal_x - start_x)**2 + (goal_y - start_y)**2)\n\n        # Generate waypoints\n        num_waypoints = max(2, int(dist / self.step_length))\n\n        for i in range(num_waypoints):\n            t = i / (num_waypoints - 1) if num_waypoints > 1 else 0\n            x = start_x + t * (goal_x - start_x)\n            y = start_y + t * (goal_y - start_y)\n\n            pose_stamped = PoseStamped()\n            pose_stamped.header.frame_id = "map"\n            pose_stamped.pose.position.x = x\n            pose_stamped.pose.position.y = y\n            pose_stamped.pose.position.z = 0.0\n\n            # Set orientation to face the goal\n            yaw = math.atan2(goal_y - y, goal_x - x)\n            quat = self.yaw_to_quaternion(yaw)\n            pose_stamped.pose.orientation = quat\n\n            path.append(pose_stamped)\n\n        return path\n\n    def execute_navigation(self, robot_pose):\n        """\n        Execute the navigation while maintaining balance\n        """\n        # This would run in a control loop\n        # For this example, we\'ll simulate the process\n\n        for i, waypoint in enumerate(self.current_path):\n            # Check if we need to generate new footsteps\n            if i % 5 == 0 or len(self.current_footsteps) == 0:  # Every 5 waypoints or if empty\n                self.current_footsteps = self.footstep_planner.plan_footsteps(\n                    self.current_path[i:], robot_pose, Twist()\n                )\n\n            # Get velocity command from path follower\n            cmd_vel = self.path_follower.compute_velocity_command(robot_pose, Twist())\n\n            if cmd_vel is None:\n                continue\n\n            # Apply balance constraints\n            balanced_cmd = self.balance_controller.apply_balance_constraints(cmd_vel)\n\n            # Execute the command (in simulation or real robot)\n            self.execute_command(balanced_cmd)\n\n            # Update robot pose (simulation)\n            robot_pose = self.update_robot_pose(robot_pose, balanced_cmd)\n\n            # Check if goal is reached\n            if self.path_follower.is_goal_reached():\n                return True\n\n        return False\n\n    def execute_command(self, cmd_vel: Twist):\n        """\n        Execute the velocity command on the robot\n        """\n        # This would interface with the robot\'s control system\n        # For simulation, we\'ll just print the command\n        print(f"Executing command: linear=({cmd_vel.linear.x}, {cmd_vel.linear.y}, {cmd_vel.linear.z}), "\n              f"angular=({cmd_vel.angular.x}, {cmd_vel.angular.y}, {cmd_vel.angular.z})")\n\n    def update_robot_pose(self, current_pose, cmd_vel: Twist):\n        """\n        Update robot pose based on velocity command (simulation)\n        """\n        # Simple kinematic update\n        dt = 0.1  # time step\n\n        # Update position\n        current_pose.pose.position.x += cmd_vel.linear.x * dt\n        current_pose.pose.position.y += cmd_vel.linear.y * dt\n\n        # Update orientation\n        current_yaw = self.get_yaw_from_quaternion(current_pose.pose.orientation)\n        new_yaw = current_yaw + cmd_vel.angular.z * dt\n\n        # Convert back to quaternion\n        new_quat = self.yaw_to_quaternion(new_yaw)\n        current_pose.pose.orientation = new_quat\n\n        return current_pose\n\n    def get_yaw_from_quaternion(self, quat) -> float:\n        """Extract yaw angle from quaternion"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def yaw_to_quaternion(self, yaw: float):\n        """Convert yaw angle to quaternion"""\n        from geometry_msgs.msg import Quaternion\n        quat = Quaternion()\n        quat.w = math.cos(yaw / 2.0)\n        quat.x = 0.0\n        quat.y = 0.0\n        quat.z = math.sin(yaw / 2.0)\n        return quat\n\nclass ZMPController:\n    """\n    Zero Moment Point (ZMP) controller for humanoid balance\n    """\n\n    def __init__(self, com_height: float = 0.8):\n        self.com_height = com_height\n        self.gravity = 9.81\n\n        # ZMP support polygon (simplified as rectangle under feet)\n        self.support_polygon = self.calculate_support_polygon()\n\n    def calculate_support_polygon(self):\n        """\n        Calculate the support polygon for ZMP based on foot positions\n        """\n        # Simplified: assume feet are at fixed positions relative to CoM\n        # In reality, this changes as feet move during walking\n        foot_separation = 0.2  # meters\n        foot_length = 0.25\n        foot_width = 0.15\n\n        # Support polygon vertices (relative to CoM projection)\n        vertices = [\n            (-foot_length/2, -foot_separation/2 - foot_width),  # Left foot back-left\n            (foot_length/2, -foot_separation/2 - foot_width),   # Left foot front-left\n            (foot_length/2, foot_separation/2 + foot_width),    # Right foot front-right\n            (-foot_length/2, foot_separation/2 + foot_width)     # Right foot back-right\n        ]\n\n        return vertices\n\n    def is_zmp_stable(self, zmp_x: float, zmp_y: float) -> bool:\n        """\n        Check if the ZMP is within the support polygon\n        """\n        # Simplified check: see if ZMP is within bounds\n        x_coords = [v[0] for v in self.support_polygon]\n        y_coords = [v[1] for v in self.support_polygon]\n\n        min_x, max_x = min(x_coords), max(x_coords)\n        min_y, max_y = min(y_coords), max(y_coords)\n\n        # Add safety margin\n        margin = 0.05  # 5cm margin\n        return (min_x + margin <= zmp_x <= max_x - margin and\n                min_y + margin <= zmp_y <= max_y - margin)\n\n    def compute_balance_correction(self, current_zmp: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Compute balance correction based on ZMP position\n        """\n        zmp_x, zmp_y = current_zmp\n\n        # Check if ZMP is outside support polygon\n        if not self.is_zmp_stable(zmp_x, zmp_y):\n            # Compute correction to bring ZMP back to center\n            x_coords = [v[0] for v in self.support_polygon]\n            y_coords = [v[1] for v in self.support_polygon]\n\n            center_x = sum(x_coords) / len(x_coords)\n            center_y = sum(y_coords) / len(y_coords)\n\n            # Proportional correction\n            correction_x = 0.5 * (center_x - zmp_x)\n            correction_y = 0.5 * (center_y - zmp_y)\n\n            return correction_x, correction_y\n\n        return 0.0, 0.0\n\nclass CapturePointController:\n    """\n    Capture Point controller for humanoid balance recovery\n    """\n\n    def __init__(self, com_height: float = 0.8, max_vel: float = 0.5):\n        self.com_height = com_height\n        self.max_vel = max_vel\n        self.gravity = 9.81\n        self.omega = math.sqrt(self.gravity / self.com_height)\n\n    def compute_capture_point(self, com_pos: Tuple[float, float],\n                            com_vel: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Compute the capture point given CoM position and velocity\n        """\n        com_x, com_y = com_pos\n        vel_x, vel_y = com_vel\n\n        capture_x = com_x + vel_x / self.omega\n        capture_y = com_y + vel_y / self.omega\n\n        return capture_x, capture_y\n\n    def compute_step_location(self, capture_point: Tuple[float, float],\n                            current_foot_pos: Tuple[float, float]) -> Tuple[float, float]:\n        """\n        Compute where to place the next foot based on capture point\n        """\n        cap_x, cap_y = capture_point\n        foot_x, foot_y = current_foot_pos\n\n        # Simple strategy: step to capture point, but limit step size\n        dx = cap_x - foot_x\n        dy = cap_y - foot_y\n\n        step_distance = math.sqrt(dx**2 + dy**2)\n        max_step_distance = 0.4  # Maximum step distance\n\n        if step_distance > max_step_distance:\n            # Scale the step\n            scale = max_step_distance / step_distance\n            dx *= scale\n            dy *= scale\n\n        target_x = foot_x + dx\n        target_y = foot_y + dy\n\n        return target_x, target_y\n\nclass HumanoidNavigationNode(Node):\n    """\n    ROS 2 node for humanoid navigation\n    """\n\n    def __init__(self):\n        super().__init__(\'humanoid_navigation\')\n\n        # Parameters\n        self.declare_parameter(\'com_height\', 0.8)\n        self.declare_parameter(\'step_length\', 0.3)\n        self.declare_parameter(\'step_duration\', 0.5)\n\n        self.com_height = self.get_parameter(\'com_height\').value\n        self.step_length = self.get_parameter(\'step_length\').value\n        self.step_duration = self.get_parameter(\'step_duration\').value\n\n        # Initialize navigation system\n        self.nav_system = HumanoidNavigationSystem()\n        self.nav_system.com_height = self.com_height\n        self.nav_system.step_length = self.step_length\n        self.nav_system.step_duration = self.step_duration\n\n        # Publishers and subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel\', 10)\n        self.path_pub = self.create_publisher(Path, \'global_plan\', 10)\n        self.current_pose_sub = self.create_subscription(\n            PoseStamped, \'current_pose\', self.pose_callback, 10)\n\n        # Navigation goal service\n        self.nav_to_pose_service = self.create_service(\n            # Would use actual service type\n        )\n\n        # TF listener\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        self.current_pose = None\n        self.navigation_active = False\n\n    def pose_callback(self, msg: PoseStamped):\n        """Handle current pose updates"""\n        self.current_pose = msg\n\n    def navigate_to_goal(self, goal_pose: PoseStamped):\n        """Navigate to the specified goal"""\n        if not self.current_pose:\n            self.get_logger().warn(\'No current pose available\')\n            return False\n\n        success = self.nav_system.navigate_to_pose(goal_pose, self.current_pose)\n        return success\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidNavigationNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"isaac-sim-setup-parameters",children:"Isaac Sim Setup Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Here's a Mermaid.js diagram showing the Nav2 architecture:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mermaid",children:"graph TB\n    A[Nav2 Navigation System] --\x3e B[Global Planner]\n    A --\x3e C[Local Planner]\n    A --\x3e D[Controller]\n    A --\x3e E[Costmap Layer]\n    A --\x3e F[Recovery Behaviors]\n\n    B --\x3e B1[A* Algorithm]\n    B --\x3e B2[Dijkstra]\n    B --\x3e B3[Custom Planners]\n\n    C --\x3e C1[Local Trajectory Planner]\n    C --\x3e C2[Obstacle Avoidance]\n    C --\x3e C3[Path Following]\n\n    D --\x3e D1[PID Controller]\n    D --\x3e D2[MPC Controller]\n    D --\x3e D3[Humanoid Controllers]\n\n    E --\x3e E1[Static Layer]\n    E --\x3e E2[Obstacle Layer]\n    E --\x3e E3[Voxel Layer]\n\n    F --\x3e F1[Clear Costmap]\n    F --\x3e F2[Rotate Recovery]\n    F --\x3e F3[Back Up]\n\n    B1 --\x3e G[Global Path]\n    C1 --\x3e H[Local Plan]\n    D1 --\x3e I[Velocity Commands]\n    G --\x3e I\n    H --\x3e I\n\n    I --\x3e J[Humanoid Robot]\n    J --\x3e K[Balance Control]\n    J --\x3e L[Step Planning]\n    J --\x3e M[Foot Control]\n\n    K --\x3e N[ZMP Controller]\n    K --\x3e O[Capture Point Controller]\n    L --\x3e P[Step Location]\n    L --\x3e Q[Step Timing]\n\n    style A fill:#e1f5fe\n    style J fill:#f3e5f5\n    style K fill:#e8f5e8\n    style L fill:#fff3e0\n"})}),"\n",(0,o.jsx)(n.p,{children:"Here are the key Nav2 configuration parameters for humanoid robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Nav2 Configuration for Humanoid Robots\nNAV2_CONFIG = {\n    # Global Planner Configuration\n    "global_planner": {\n        "plugin": "nav2_navfn_planner/NavfnPlanner",\n        "frequency": 1.0,\n        "max_iterations": 50000,\n        "max_on_approach_iterations": 1000,\n        "use_astar": False,\n        "allow_unknown": True,\n        "tolerance": 0.5  # Increased tolerance for humanoid\n    },\n\n    # Local Planner Configuration\n    "local_planner": {\n        "plugin": "nav2_dwb_controller/DWBLocalPlanner",\n        "prune_plan": True,\n        "prune_distance": 1.0,\n        "debug_trajectory_details": False,\n        "allow_unkown": True,\n        "clearing_radius": 0.5,\n        "goal_checker": "nav2_goal_checker/BasicGoalChecker",\n        "goal_check_tolerance": 0.25,\n        "rotate_to_goal": {\n            "enabled": True,\n            "max_angular_velocity": 1.0,\n            "min_angle": 0.1\n        }\n    },\n\n    # Controller Configuration\n    "controller": {\n        "plugin": "nav2_regulated_pure_pursuit_controller/RegulatedPurePursuitController",\n        "max_linear_speed": 0.5,  # Reduced for humanoid stability\n        "min_linear_speed": 0.1,\n        "max_angular_speed": 1.0,\n        "min_angular_speed": 0.05,\n        "inflation_cost_scaling_factor": 3.0,\n        "cost_scaling_dist": 0.6,\n        "lookahead_dist": 0.6,\n        "min_lookahead_dist": 0.3,\n        "max_lookahead_dist": 0.9,\n        "use_velocity_scaled_lookahead_dist": True,\n        "lookahead_time": 1.5,\n        "min_lookahead_time": 1.0,\n        "max_lookahead_time": 2.0,\n        "use_interpolation": True,\n        "desired_linear_vel": 0.3,  # Conservative for humanoid\n        "max_linear_accel": 0.8,\n        "max_linear_decel": 0.8,\n        "xy_goal_tolerance": 0.25,\n        "trans_stopped_velocity": 0.05,\n        "shortest_pos_path": False\n    },\n\n    # Costmap Configuration\n    "global_costmap": {\n        "global_frame": "map",\n        "robot_base_frame": "base_link",\n        "update_frequency": 1.0,\n        "publish_frequency": 1.0,\n        "transform_tolerance": 0.5,\n        "width": 40,\n        "height": 40,\n        "resolution": 0.05,\n        "origin_x": -10.0,\n        "origin_y": -10.0,\n        "plugins": [\n            {"id": "static_layer", "type": "nav2_costmap_2d::StaticLayer"},\n            {"id": "obstacle_layer", "type": "nav2_costmap_2d::ObstacleLayer"},\n            {"id": "inflation_layer", "type": "nav2_costmap_2d::InflationLayer"}\n        ],\n        "static_layer": {\n            "map_topic": "map",\n            "enabled": True,\n            "subscribe_to_updates": True,\n            "track_unknown_space": True,\n            "use_maximum": False,\n            "unknown_cost_value": -1,\n            "trinary_costmap": True,\n            "transform_tolerance": 0.5,\n            "mode": "trinary",\n            "footprint": [\n                [-0.25, -0.2],  # Humanoid approximate footprint\n                [-0.25, 0.2],\n                [0.25, 0.2],\n                [0.25, -0.2]\n            ]\n        },\n        "obstacle_layer": {\n            "enabled": True,\n            "observation_sources": "scan",\n            "scan": {\n                "topic": "/scan",\n                "max_obstacle_height": 2.0,\n                "raytrace_range": 3.0,\n                "obstacle_range": 2.5,\n                "inf_is_valid": True,\n                "clearing": True,\n                "marking": True\n            }\n        },\n        "inflation_layer": {\n            "enabled": True,\n            "cost_scaling_factor": 3.0,\n            "inflation_radius": 0.55,  # Increased for humanoid safety\n            "inflate_unknown": False,\n            "inflate_around_unknown": True\n        }\n    },\n\n    "local_costmap": {\n        "global_frame": "odom",\n        "robot_base_frame": "base_link",\n        "update_frequency": 5.0,\n        "publish_frequency": 2.0,\n        "transform_tolerance": 0.5,\n        "width": 6,\n        "height": 6,\n        "resolution": 0.05,\n        "origin_x": -3.0,\n        "origin_y": -3.0,\n        "plugins": [\n            {"id": "obstacle_layer", "type": "nav2_costmap_2d::ObstacleLayer"},\n            {"id": "voxel_layer", "type": "nav2_costmap_2d::VoxelLayer"},\n            {"id": "inflation_layer", "type": "nav2_costmap_2d::InflationLayer"}\n        ],\n        "obstacle_layer": {\n            "enabled": True,\n            "observation_sources": "scan",\n            "scan": {\n                "topic": "/scan",\n                "max_obstacle_height": 2.0,\n                "raytrace_range": 3.0,\n                "obstacle_range": 2.5,\n                "inf_is_valid": True,\n                "clearing": True,\n                "marking": True\n            }\n        },\n        "voxel_layer": {\n            "enabled": True,\n            "publish_voxel_map": True,\n            "origin_z": 0.0,\n            "z_resolution": 0.2,\n            "z_voxels": 10,\n            "max_obstacle_height": 2.0,\n            "mark_threshold": 0,\n            "observation_sources": "scan",\n            "scan": {\n                "topic": "/scan",\n                "max_obstacle_height": 2.0,\n                "raytrace_range": 3.0,\n                "obstacle_range": 2.5,\n                "inf_is_valid": True,\n                "clearing": True,\n                "marking": True\n            }\n        },\n        "inflation_layer": {\n            "enabled": True,\n            "cost_scaling_factor": 3.0,\n            "inflation_radius": 0.55,\n            "inflate_unknown": False,\n            "inflate_around_unknown": True\n        }\n    },\n\n    # Humanoid-Specific Parameters\n    "humanoid_nav": {\n        "step_length": 0.3,      # meters\n        "step_duration": 0.5,    # seconds\n        "max_lean_angle": 0.2,   # radians\n        "com_height": 0.8,       # meters\n        "foot_separation": 0.2,  # meters\n        "balance_margin": 0.1,   # safety margin for balance\n        "max_step_up": 0.1,      # maximum step up height\n        "max_step_down": 0.1     # maximum step down height\n    },\n\n    # Recovery Behaviors\n    "recoveries": {\n        "frequency": 10.0,\n        "plugins": [\n            {"id": "spin", "type": "nav2_recoveries/Spin"},\n            {"id": "backup", "type": "nav2_recoveries/BackUp"},\n            {"id": "drive_on_heading", "type": "nav2_recoveries/DriveOnHeading"},\n            {"id": "wait", "type": "nav2_recoveries/Wait"}\n        ],\n        "spin": {\n            "enabled": True,\n            "simulate_ahead_time": 2.0,\n            "max_angular_accel": 1.0,\n            "max_rotational_vel": 1.0,\n            "min_rotational_vel": 0.4,\n            "tolerance": 1.57  # 90 degrees\n        },\n        "backup": {\n            "enabled": True,\n            "simulate_ahead_time": 2.0,\n            "max_linear_accel": 0.8,\n            "max_translational_vel": 0.25,\n            "min_translational_vel": 0.025,\n            "translational_tolerance": 0.25,\n            "heading_scoring_plugin": "progress_checker",\n            "heading_scoring_enabled": True\n        },\n        "drive_on_heading": {\n            "enabled": True,\n            "simulate_ahead_time": 2.0,\n            "max_angular_accel": 1.0,\n            "max_rotational_vel": 1.0,\n            "min_rotational_vel": 0.4,\n            "max_linear_accel": 0.8,\n            "max_translational_vel": 0.25,\n            "min_translational_vel": 0.025,\n            "longitudinal_angle_threshold": 0.25,\n            "forward_sampling_distance": 0.5,\n            "lateral_sampling_distance": 0.5\n        },\n        "wait": {\n            "enabled": True,\n            "simulated_time": 5.0\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Nav2 provides a comprehensive navigation solution for humanoid robots with specialized capabilities for bipedal locomotion and balance. The system includes:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Global Path Planning"}),": A* and Dijkstra algorithms for finding optimal paths while considering humanoid-specific constraints like step length and balance."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Local Path Planning"}),": Real-time path following with obstacle avoidance, considering the robot's dynamic stability and step planning requirements."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Controller Plugins"}),": Specialized controllers including PID and Model Predictive Control (MPC) for precise navigation with balance maintenance."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Costmap Management"}),": Layered costmaps that represent the environment with static and dynamic obstacles, considering the humanoid's unique shape and locomotion constraints."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Humanoid-Specific Navigation"}),": Advanced features like ZMP (Zero Moment Point) control, Capture Point control, and footstep planning for stable bipedal navigation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The implementation includes comprehensive Python classes for each component of the navigation stack, with special attention to balance control, step planning, and stability considerations that are critical for humanoid robot navigation. The system is designed to be configurable for different humanoid platforms and environments, with parameters that can be tuned based on specific robot capabilities and application requirements."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>r});var a=t(6540);const o={},s=a.createContext(o);function l(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);